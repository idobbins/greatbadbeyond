#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer PackedSpheres {
    uint words[];
} spheres;
layout(std430, binding = 2) readonly buffer GridCells {
    uvec2 cells[];
} gridCells;
layout(std430, binding = 3) readonly buffer GridIndices {
    uint indices[];
} gridIndices;
layout(push_constant) uniform Scene {
    vec4 origin;
    vec4 forward_fov;
    vec4 scene_min;
    vec4 scene_extent;
    vec4 radius_min_max;
    uvec4 counts;
    uvec4 grid_dims;
} pc;

struct Ray {
    vec3 origin;
    vec3 dir;
};

const vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);
const vec3 SUN_DIR = normalize(vec3(0.55, 0.85, 0.25));
const int MAX_BOUNCES = 3;

vec3 skyColor(vec3 dir)
{
    float t = 0.5 * (dir.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), clamp(t, 0.0, 1.0));
}

bool hitSphere(vec3 center, float radius, Ray r, out float t)
{
    vec3 oc = r.origin - center;
    float a = dot(r.dir, r.dir);
    float h = dot(oc, r.dir);
    float c = dot(oc, oc) - radius * radius;
    float disc = h * h - a * c;
    if (disc <= 0.0) return false;
    float root = sqrt(disc);
    float t0 = (-h - root) / a;
    if (t0 > 0.001) { t = t0; return true; }
    float t1 = (-h + root) / a;
    if (t1 > 0.001) { t = t1; return true; }
    return false;
}

void decodeSphere(uint sphereIndex, out vec3 center, out float radius, out uint materialId)
{
    uint w0 = spheres.words[sphereIndex * 2u + 0u];
    uint w1 = spheres.words[sphereIndex * 2u + 1u];

    uint qx = w0 & 0xffffu;
    uint qy = (w0 >> 16u) & 0xffffu;
    uint qz = w1 & 0xffffu;
    uint qRadius = (w1 >> 16u) & 0x0fffu;
    materialId = min((w1 >> 28u) & 0x0fu, 2u);

    vec3 q = vec3(float(qx), float(qy), float(qz)) * (1.0 / 65535.0);
    center = pc.scene_min.xyz + q * pc.scene_extent.xyz;

    float encoded = float(qRadius) * (1.0 / 4095.0);
    float radiusNorm = encoded * encoded;
    radius = mix(pc.radius_min_max.x, pc.radius_min_max.y, radiusNorm);
}

uint hash32(uint x)
{
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}

float random01(inout uint state)
{
    state = hash32(state);
    return float(state) * (1.0 / 4294967296.0);
}

vec3 checkerAlbedo(vec3 hitPos)
{
    vec2 checkerCoord = floor(hitPos.xz);
    float checker = abs(mod(checkerCoord.x + checkerCoord.y, 2.0));
    vec3 floorA = vec3(0.11, 0.12, 0.13);
    vec3 floorB = vec3(0.18, 0.19, 0.20);
    return mix(floorA, floorB, checker);
}

vec3 sampleHemisphere(vec3 n, inout uint seed)
{
    float u1 = random01(seed);
    float u2 = random01(seed);
    float r = sqrt(u1);
    float theta = 6.2831853 * u2;

    vec3 tangent = normalize(abs(n.y) > 0.999 ? cross(n, vec3(1.0, 0.0, 0.0)) : cross(WORLD_UP, n));
    vec3 bitangent = cross(n, tangent);
    vec3 local = vec3(r * cos(theta), sqrt(max(0.0, 1.0 - u1)), r * sin(theta));
    return normalize(tangent * local.x + n * local.y + bitangent * local.z);
}

void getSphereMaterial(uint materialId, out vec3 albedo, out float metalness, out float ior)
{
    if (materialId == 0u)
    {
        albedo = vec3(0.78, 0.44, 0.22);
        metalness = 0.0;
        ior = 1.0;
        return;
    }
    if (materialId == 1u)
    {
        albedo = vec3(0.56, 0.58, 0.62);
        metalness = 1.0;
        ior = 1.0;
        return;
    }
    albedo = vec3(0.97, 0.99, 1.0);
    metalness = 0.0;
    ior = 1.45;
}

bool traceSpheresGrid(Ray ray, inout float minT, inout vec3 hitCenter, inout uint hitMaterial)
{
    ivec3 dims = ivec3(pc.grid_dims.xyz);
    if (any(lessThanEqual(dims, ivec3(0)))) return false;
    if ((pc.counts.y == 0u) || (pc.counts.z == 0u)) return false;

    vec3 boundsMin = pc.scene_min.xyz;
    vec3 boundsMax = pc.scene_min.xyz + pc.scene_extent.xyz;
    vec3 dir = ray.dir;
    vec3 invDir = vec3(
        (abs(dir.x) > 1e-6) ? (1.0 / dir.x) : ((dir.x >= 0.0) ? 1e30 : -1e30),
        (abs(dir.y) > 1e-6) ? (1.0 / dir.y) : ((dir.y >= 0.0) ? 1e30 : -1e30),
        (abs(dir.z) > 1e-6) ? (1.0 / dir.z) : ((dir.z >= 0.0) ? 1e30 : -1e30));

    vec3 t0 = (boundsMin - ray.origin) * invDir;
    vec3 t1 = (boundsMax - ray.origin) * invDir;
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    float tEnter = max(max(tNear.x, tNear.y), max(tNear.z, 0.0));
    float tExit = min(min(tFar.x, tFar.y), tFar.z);
    if (tExit < tEnter) return false;

    vec3 cellSize = pc.scene_extent.xyz / vec3(dims);
    vec3 safeCellSize = max(cellSize, vec3(1e-5));
    vec3 startPos = ray.origin + dir * tEnter;
    vec3 rel = (startPos - boundsMin) / safeCellSize;
    rel = clamp(rel, vec3(0.0), vec3(dims) - vec3(1e-4));
    ivec3 cell = ivec3(floor(rel));

    ivec3 step = ivec3(
        (dir.x > 0.0) ? 1 : ((dir.x < 0.0) ? -1 : 0),
        (dir.y > 0.0) ? 1 : ((dir.y < 0.0) ? -1 : 0),
        (dir.z > 0.0) ? 1 : ((dir.z < 0.0) ? -1 : 0));

    vec3 cellMin = boundsMin + vec3(cell) * safeCellSize;
    vec3 cellMax = cellMin + safeCellSize;
    vec3 tMax;
    tMax.x = (step.x > 0) ? (cellMax.x - ray.origin.x) * invDir.x : ((step.x < 0) ? (cellMin.x - ray.origin.x) * invDir.x : 1e30);
    tMax.y = (step.y > 0) ? (cellMax.y - ray.origin.y) * invDir.y : ((step.y < 0) ? (cellMin.y - ray.origin.y) * invDir.y : 1e30);
    tMax.z = (step.z > 0) ? (cellMax.z - ray.origin.z) * invDir.z : ((step.z < 0) ? (cellMin.z - ray.origin.z) * invDir.z : 1e30);
    vec3 tDelta = vec3(
        (step.x != 0) ? abs(safeCellSize.x * invDir.x) : 1e30,
        (step.y != 0) ? abs(safeCellSize.y * invDir.y) : 1e30,
        (step.z != 0) ? abs(safeCellSize.z * invDir.z) : 1e30);

    uint strideY = uint(dims.x);
    uint strideZ = uint(dims.x * dims.y);
    bool hit = false;
    float currentT = tEnter;
    while ((cell.x >= 0) && (cell.x < dims.x) &&
           (cell.y >= 0) && (cell.y < dims.y) &&
           (cell.z >= 0) && (cell.z < dims.z) &&
           (currentT <= tExit) && (currentT <= minT))
    {
        uint linearIndex = uint(cell.x) + strideY * uint(cell.y) + strideZ * uint(cell.z);
        if (linearIndex < pc.counts.y)
        {
            uvec2 cellInfo = gridCells.cells[linearIndex];
            uint offset = cellInfo.x;
            uint count = cellInfo.y;
            uint end = min(offset + count, pc.counts.z);
            for (uint idx = offset; idx < end; ++idx)
            {
                uint sphereIndex = gridIndices.indices[idx];
                if (sphereIndex >= pc.counts.x) continue;
                vec3 center;
                float radius;
                uint materialId;
                decodeSphere(sphereIndex, center, radius, materialId);
                float t = 0.0;
                if (hitSphere(center, radius, ray, t) && (t < minT))
                {
                    minT = t;
                    hitCenter = center;
                    hitMaterial = materialId;
                    hit = true;
                }
            }
        }

        float nextT = min(tMax.x, min(tMax.y, tMax.z));
        if (minT <= nextT) break;
        if (tMax.x <= tMax.y && tMax.x <= tMax.z)
        {
            cell.x += step.x;
            tMax.x += tDelta.x;
        }
        else if (tMax.y <= tMax.z)
        {
            cell.y += step.y;
            tMax.y += tDelta.y;
        }
        else
        {
            cell.z += step.z;
            tMax.z += tDelta.z;
        }
        currentT = nextT;
    }
    return hit;
}

bool traceScene(Ray ray, bool gridAvailable, out int hitType, out float hitT, out vec3 hitNormal, out vec3 hitPos, out uint hitMaterial)
{
    hitType = 0;
    hitT = 1e30;
    hitNormal = vec3(0.0);
    hitPos = vec3(0.0);
    hitMaterial = 0u;

    if (abs(ray.dir.y) > 1e-5)
    {
        float planeT = -ray.origin.y / ray.dir.y;
        if ((planeT > 0.001) && (planeT < hitT))
        {
            hitType = 2;
            hitT = planeT;
            hitNormal = WORLD_UP;
            hitPos = ray.origin + ray.dir * hitT;
        }
    }

    if (gridAvailable)
    {
        float sphereT = hitT;
        vec3 sphereCenter = vec3(0.0);
        uint sphereMaterial = 0u;
        if (traceSpheresGrid(ray, sphereT, sphereCenter, sphereMaterial) && (sphereT < hitT))
        {
            hitType = 1;
            hitT = sphereT;
            hitPos = ray.origin + ray.dir * hitT;
            hitNormal = normalize(hitPos - sphereCenter);
            hitMaterial = sphereMaterial;
        }
    }

    return hitType != 0;
}

void main()
{
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);
    ivec2 sz = imageSize(outImage);
    if (any(greaterThanEqual(p, sz))) return;

    vec2 uv = ((vec2(p) + 0.5) / vec2(sz)) * 2.0 - 1.0;
    uv.y = -uv.y;

    vec3 forward = normalize(pc.forward_fov.xyz);
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(forward, worldUp));
    vec3 up = cross(right, forward);
    float aspect = float(sz.x) / float(sz.y);
    float halfFovTan = tan(pc.forward_fov.w * 0.5);
    vec3 dir = normalize(forward + uv.x * right * (halfFovTan * aspect) + uv.y * up * halfFovTan);

    bool gridAvailable =
        (pc.counts.y > 0u) &&
        (pc.counts.z > 0u) &&
        all(greaterThan(pc.grid_dims.xyz, uvec3(0u)));

    uint seed = (uint(p.x) * 1973u) ^ (uint(p.y) * 9277u) ^ 0x68bc21ebu;
    Ray ray = Ray(pc.origin.xyz, dir);
    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);

    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce)
    {
        int hitType = 0;
        float hitT = 0.0;
        vec3 hitNormal = vec3(0.0);
        vec3 hitPos = vec3(0.0);
        uint hitMaterial = 0u;
        if (!traceScene(ray, gridAvailable, hitType, hitT, hitNormal, hitPos, hitMaterial))
        {
            radiance += throughput * skyColor(ray.dir);
            break;
        }

        if (hitType == 2)
        {
            vec3 albedo = checkerAlbedo(hitPos);
            float ndl = max(dot(hitNormal, SUN_DIR), 0.0);
            radiance += throughput * albedo * (0.08 + 0.12 * ndl);
            throughput *= albedo;
            ray.origin = hitPos + hitNormal * 0.001;
            ray.dir = sampleHemisphere(hitNormal, seed);
        }
        else
        {
            vec3 albedo = vec3(1.0);
            float metalness = 0.0;
            float ior = 1.0;
            getSphereMaterial(hitMaterial, albedo, metalness, ior);
            float ndl = max(dot(hitNormal, SUN_DIR), 0.0);
            radiance += throughput * albedo * (0.04 + 0.16 * ndl);

            if (ior > 1.01)
            {
                vec3 n = hitNormal;
                float eta = 1.0 / ior;
                float cosi = dot(-ray.dir, n);
                if (cosi < 0.0)
                {
                    n = -n;
                    eta = ior;
                    cosi = dot(-ray.dir, n);
                }
                vec3 refrDir = refract(ray.dir, n, eta);
                float f0 = (ior - 1.0) / (ior + 1.0);
                f0 *= f0;
                float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(cosi, 0.0, 1.0), 5.0);
                bool useReflect = (length(refrDir) < 1e-5) || (random01(seed) < fresnel);
                vec3 newDir = useReflect ? reflect(ray.dir, n) : refrDir;
                ray.origin = hitPos + n * 0.001;
                ray.dir = normalize(newDir);
                throughput *= albedo;
            }
            else if (metalness > 0.5)
            {
                vec3 reflDir = reflect(ray.dir, hitNormal);
                vec3 fuzzDir = sampleHemisphere(hitNormal, seed);
                ray.origin = hitPos + hitNormal * 0.001;
                ray.dir = normalize(mix(reflDir, fuzzDir, 0.08));
                throughput *= albedo;
            }
            else
            {
                ray.origin = hitPos + hitNormal * 0.001;
                ray.dir = sampleHemisphere(hitNormal, seed);
                throughput *= albedo;
            }
        }

        if (bounce >= 1)
        {
            float pCont = clamp(max(throughput.r, max(throughput.g, throughput.b)), 0.05, 0.95);
            if (random01(seed) > pCont)
            {
                break;
            }
            throughput /= pCont;
        }
    }

    imageStore(outImage, p, vec4(radiance, 1.0));
}
