#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(push_constant) uniform Camera {
    vec4 focus_zoom;
    vec4 params;
} cam;

struct Ray {
    vec3 origin;
    vec3 dir;
};

const float PI = 3.14159265359;
const float CAMERA_YAW = PI * 0.25;
const float CAMERA_PITCH = -PI * 0.25;
const vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);
const vec3 SUN_DIR = normalize(vec3(0.45, 0.85, 0.25));

const int GRID_SIZE = 10;
const float SPHERE_RADIUS = 0.45;
const float SPHERE_SPACING = 1.6;

float hitSphere(vec3 center, float radius, Ray ray)
{
    vec3 oc = ray.origin - center;
    float a = dot(ray.dir, ray.dir);
    float h = dot(oc, ray.dir);
    float c = dot(oc, oc) - radius * radius;
    float disc = h * h - a * c;
    if (disc < 0.0) return -1.0;
    float rootDisc = sqrt(disc);
    float t0 = (-h - rootDisc) / a;
    float t1 = (-h + rootDisc) / a;
    if (t0 > 0.001) return t0;
    if (t1 > 0.001) return t1;
    return -1.0;
}

float hitGroundPlane(Ray ray)
{
    if (abs(ray.dir.y) < 1e-5) return -1.0;
    float t = -ray.origin.y / ray.dir.y;
    return (t > 0.001) ? t : -1.0;
}

vec3 skyColor(vec3 dir)
{
    float upAmount = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 horizon = vec3(0.79, 0.87, 0.99);
    vec3 zenith = vec3(0.18, 0.38, 0.73);
    vec3 nadir = vec3(0.67, 0.73, 0.82);
    vec3 base = (dir.y >= 0.0)
        ? mix(horizon, zenith, pow(clamp(dir.y, 0.0, 1.0), 0.7))
        : mix(nadir, horizon, upAmount);
    float sun = pow(max(dot(dir, SUN_DIR), 0.0), 384.0);
    return base + vec3(1.0, 0.96, 0.86) * sun * 1.4;
}

vec3 groundChecker(vec3 p)
{
    vec2 cell = floor(p.xz);
    float checker = mod(cell.x + cell.y, 2.0);
    vec3 dark = vec3(0.17, 0.18, 0.19);
    vec3 light = vec3(0.82, 0.83, 0.80);
    vec3 base = mix(dark, light, checker);

    vec2 fracCell = abs(fract(p.xz) - 0.5);
    float edge = 1.0 - smoothstep(0.47, 0.50, max(fracCell.x, fracCell.y));
    return mix(base, vec3(0.09), edge * 0.35);
}

vec3 sphereColor(int x, int z)
{
    float idx = float(x * GRID_SIZE + z);
    return 0.55 + 0.45 * cos(6.2831853 * (vec3(0.10, 0.38, 0.63) + idx * vec3(0.071, 0.113, 0.173)));
}

void main()
{
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);
    ivec2 sz = imageSize(outImage);
    if (any(greaterThanEqual(p, sz))) return;

    vec2 uv = ((vec2(p) + 0.5) / vec2(sz)) * 2.0 - 1.0;
    uv.y = -uv.y;

    float pitchCos = cos(CAMERA_PITCH);
    vec3 forward = normalize(vec3(sin(CAMERA_YAW) * pitchCos, sin(CAMERA_PITCH), cos(CAMERA_YAW) * pitchCos));
    vec3 right = normalize(cross(forward, WORLD_UP));
    vec3 up = cross(right, forward);
    vec3 origin = cam.focus_zoom.xyz - forward * cam.focus_zoom.w;

    float aspect = float(sz.x) / float(sz.y);
    float halfFovTan = tan(cam.params.x * 0.5);
    float halfHeight = halfFovTan;
    float halfWidth = halfFovTan * aspect;
    vec3 dir = normalize(forward + uv.x * right * halfWidth + uv.y * up * halfHeight);

    Ray ray = Ray(origin, dir);

    float nearestT = 1e30;
    vec3 nearestN = vec3(0.0);
    vec3 nearestAlbedo = vec3(0.0);
    bool hit = false;

    float groundT = hitGroundPlane(ray);
    if (groundT > 0.0)
    {
        nearestT = groundT;
        vec3 hitPos = ray.origin + ray.dir * groundT;
        nearestN = WORLD_UP;
        nearestAlbedo = groundChecker(hitPos);
        hit = true;
    }

    float halfGrid = 0.5 * float(GRID_SIZE - 1);
    for (int z = 0; z < GRID_SIZE; ++z)
    {
        for (int x = 0; x < GRID_SIZE; ++x)
        {
            vec3 center = vec3((float(x) - halfGrid) * SPHERE_SPACING,
                               SPHERE_RADIUS,
                               (float(z) - halfGrid) * SPHERE_SPACING);
            float t = hitSphere(center, SPHERE_RADIUS, ray);
            if ((t > 0.0) && (t < nearestT))
            {
                nearestT = t;
                vec3 hitPos = ray.origin + ray.dir * t;
                nearestN = normalize(hitPos - center);
                nearestAlbedo = sphereColor(x, z);
                hit = true;
            }
        }
    }

    vec3 sky = skyColor(ray.dir);
    vec3 col = sky;
    if (hit)
    {
        float ndl = max(dot(nearestN, SUN_DIR), 0.0);
        float hemi = 0.5 + 0.5 * nearestN.y;
        vec3 ambient = vec3(0.14, 0.17, 0.22) * hemi;
        vec3 diffuse = vec3(1.0, 0.97, 0.90) * ndl;

        vec3 halfVec = normalize(SUN_DIR - ray.dir);
        float spec = pow(max(dot(nearestN, halfVec), 0.0), 48.0);

        col = nearestAlbedo * (ambient + diffuse * 0.9) + vec3(1.0) * spec * 0.20;

    }

    imageStore(outImage, p, vec4(col, 1.0));
}
