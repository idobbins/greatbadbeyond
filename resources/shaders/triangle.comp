#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer DataBuffer
{
    uint words[];
} scene;

const uint HDR_CAM_POS_X = 0u;
const uint HDR_CAM_POS_Y = 1u;
const uint HDR_CAM_POS_Z = 2u;
const uint HDR_CAM_YAW = 3u;
const uint HDR_CAM_PITCH = 4u;
const uint HDR_CAM_FOV_Y = 8u;
const uint HDR_BRICK_COUNT = 15u;
const uint HDR_BRICK_POOL_OFFSET_WORDS = 17u;

float LoadF(uint wordIndex)
{
    return uintBitsToFloat(scene.words[wordIndex]);
}

vec3 GradeColor(vec3 c)
{
    c *= 1.08;

    const vec3 lumaWeights = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(c, lumaWeights);
    c = mix(vec3(luma), c, 1.20);

    c = (c - vec3(0.5)) * 1.10 + vec3(0.5);
    c = clamp(c, vec3(0.0), vec3(8.0));
    c = (c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14);
    return c;
}

bool IsVoxelSet(uint occLo, uint occHi, ivec3 cell)
{
    uint index = uint(cell.x + cell.y * 4 + cell.z * 16);
    uint bit = 1u << (index & 31u);
    uint word = index < 32u ? occLo : occHi;
    return (word & bit) != 0u;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizePx = imageSize(outImage);
    if (pixel.x >= imageSizePx.x || pixel.y >= imageSizePx.y)
    {
        return;
    }

    vec3 cameraPos = vec3(LoadF(HDR_CAM_POS_X), LoadF(HDR_CAM_POS_Y), LoadF(HDR_CAM_POS_Z));
    float yaw = LoadF(HDR_CAM_YAW);
    float pitch = LoadF(HDR_CAM_PITCH);
    float fovY = LoadF(HDR_CAM_FOV_Y);

    uint brickCount = scene.words[HDR_BRICK_COUNT];
    uint brickBaseWord = scene.words[HDR_BRICK_POOL_OFFSET_WORDS];
    uint occLo = scene.words[brickBaseWord + 0u];
    uint occHi = scene.words[brickBaseWord + 1u];
    vec3 brickMin = vec3(
        LoadF(brickBaseWord + 2u),
        LoadF(brickBaseWord + 3u),
        LoadF(brickBaseWord + 4u));
    float voxelSize = LoadF(brickBaseWord + 5u);
    vec3 brickMax = brickMin + vec3(voxelSize * 4.0);

    float cosPitch = cos(pitch);
    float sinPitch = sin(pitch);
    float cosYaw = cos(yaw);
    float sinYaw = sin(yaw);

    vec3 forward = normalize(vec3(cosPitch * cosYaw, sinPitch, cosPitch * sinYaw));
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(forward, worldUp));
    vec3 up = normalize(cross(right, forward));

    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(imageSizePx);
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;

    float aspect = float(imageSizePx.x) / float(imageSizePx.y);
    float tanHalfFov = tan(fovY * 0.5);
    vec3 rayDir = normalize(forward + right * (ndc.x * aspect * tanHalfFov) + up * (ndc.y * tanHalfFov));

    vec3 skyHorizon = vec3(0.92, 0.62, 0.34);
    vec3 skyTop = vec3(0.18, 0.35, 0.85);
    float skyT = clamp(rayDir.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 sky = mix(skyHorizon, skyTop, skyT);

    vec3 invDir = 1.0 / mix(rayDir, vec3(1e-6), lessThan(abs(rayDir), vec3(1e-6)));
    vec3 t0 = (brickMin - cameraPos) * invDir;
    vec3 t1 = (brickMax - cameraPos) * invDir;
    vec3 tMin3 = min(t0, t1);
    vec3 tMax3 = max(t0, t1);
    float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
    float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

    bool hit = false;
    ivec3 hitCell = ivec3(0);

    if (brickCount != 0u && tExit >= max(tEnter, 0.0))
    {
        float t = max(tEnter, 0.0) + 1e-4;
        vec3 p = cameraPos + rayDir * t;

        vec3 local = clamp((p - brickMin) / voxelSize, vec3(0.0), vec3(3.9999));
        ivec3 cell = ivec3(floor(local));
        ivec3 stepDir = ivec3(sign(rayDir));
        vec3 cellMin = brickMin + vec3(cell) * voxelSize;
        vec3 cellMax = cellMin + vec3(voxelSize);
        vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
        vec3 safeDir = mix(rayDir, vec3(1e-6), lessThan(abs(rayDir), vec3(1e-6)));
        vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
        vec3 tDelta = abs(vec3(voxelSize) / safeDir);

        for (uint i = 0u; i < 64u; i++)
        {
            bool inside = (cell.x >= 0 && cell.x < 4 &&
                           cell.y >= 0 && cell.y < 4 &&
                           cell.z >= 0 && cell.z < 4);
            if (!inside)
            {
                break;
            }

            if (IsVoxelSet(occLo, occHi, cell))
            {
                hit = true;
                hitCell = cell;
                break;
            }

            bool stepX = (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
            bool stepY = (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
            bool stepZ = (!stepX) && (!stepY);

            ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
            cell += axisStep * stepDir;

            vec3 stepMask = vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0);
            tMaxAxis += stepMask * tDelta;
        }
    }

    vec3 color = sky;
    if (hit)
    {
        vec3 cellColor = vec3(float(hitCell.x), float(hitCell.y), float(hitCell.z)) / 3.0;
        color = mix(vec3(0.12, 0.15, 0.18), cellColor, 0.85);
    }

    color = GradeColor(color);
    imageStore(outImage, pixel, vec4(color, 1.0));
}
