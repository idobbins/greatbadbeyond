#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer DataBuffer
{
    uint words[];
} scene;

const uint HDR_CAM_POS_X = 0u;
const uint HDR_CAM_POS_Y = 1u;
const uint HDR_CAM_POS_Z = 2u;
const uint HDR_CAM_YAW = 3u;
const uint HDR_CAM_PITCH = 4u;
const uint HDR_CAM_FOV_Y = 8u;
const uint HDR_GRID_MIN_X = 9u;
const uint HDR_GRID_MIN_Y = 10u;
const uint HDR_GRID_MIN_Z = 11u;
const uint HDR_GRID_DIM_X = 12u;
const uint HDR_GRID_DIM_Y = 13u;
const uint HDR_GRID_DIM_Z = 14u;
const uint HDR_BRICK_COUNT = 15u;
const uint HDR_BRICK_TABLE_OFFSET_WORDS = 16u;
const uint HDR_BRICK_POOL_OFFSET_WORDS = 17u;
const uint HDR_CAM_FORWARD_X = 18u;
const uint HDR_CAM_FORWARD_Y = 19u;
const uint HDR_CAM_FORWARD_Z = 20u;
const uint HDR_CAM_RIGHT_X = 21u;
const uint HDR_CAM_RIGHT_Y = 22u;
const uint HDR_CAM_RIGHT_Z = 23u;
const uint HDR_CAM_UP_X = 24u;
const uint HDR_CAM_UP_Y = 25u;
const uint HDR_CAM_UP_Z = 26u;
const uint HDR_CAM_TAN_HALF_FOV_Y = 27u;
const uint BRICK_WORD_STRIDE = 16u;
const uint EMPTY_BRICK_SLOT = 0xFFFFFFFFu;
const uint MAX_GLOBAL_STEPS = 38u;
const uint MAX_LOCAL_STEPS = 22u;

float LoadF(uint wordIndex)
{
    return uintBitsToFloat(scene.words[wordIndex]);
}

int SelectInt(int a, int b, bool selectB)
{
    return selectB ? b : a;
}

uint SelectUInt(uint a, uint b, bool selectB)
{
    return selectB ? b : a;
}

ivec3 SelectIVec3(ivec3 a, ivec3 b, bool selectB)
{
    return ivec3(
        SelectInt(a.x, b.x, selectB),
        SelectInt(a.y, b.y, selectB),
        SelectInt(a.z, b.z, selectB));
}

vec3 GradeColor(vec3 c)
{
    c *= 1.08;

    const vec3 lumaWeights = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(c, lumaWeights);
    c = mix(vec3(luma), c, 1.20);

    c = (c - vec3(0.5)) * 1.10 + vec3(0.5);
    c = clamp(c, vec3(0.0), vec3(8.0));
    c = (c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14);
    return c;
}

bool IsVoxelSet(uint occLo, uint occHi, ivec3 cell)
{
    uint index = uint(cell.x + cell.y * 4 + cell.z * 16);
    uint bit = 1u << (index & 31u);
    uint wordIndex = index >> 5u;
    uvec2 packed = uvec2(occLo, occHi);
    uint word = packed[wordIndex];
    return (word & bit) != 0u;
}

uint GridLinearIndex(ivec3 cell, ivec3 dim)
{
    return uint(cell.x + cell.y * dim.x + cell.z * dim.x * dim.y);
}

bool TraceBrick(vec3 rayOrigin, vec3 rayDir, vec3 safeDir, vec3 invDir, uint occLo, uint occHi, vec3 brickMin, float voxelSize, out ivec3 hitCell)
{
    vec3 brickMax = brickMin + vec3(voxelSize * 4.0);
    vec3 t0 = (brickMin - rayOrigin) * invDir;
    vec3 t1 = (brickMax - rayOrigin) * invDir;
    vec3 tMin3 = min(t0, t1);
    vec3 tMax3 = max(t0, t1);
    float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
    float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

    bool localActive = tExit >= max(tEnter, 0.0);
    bool hit = false;
    hitCell = ivec3(0);

    float t = max(tEnter, 0.0) + 1e-4;
    vec3 p = rayOrigin + rayDir * t;
    vec3 local = clamp((p - brickMin) / voxelSize, vec3(0.0), vec3(3.9999));
    ivec3 cell = ivec3(floor(local));
    ivec3 stepDir = ivec3(sign(rayDir));
    vec3 cellMin = brickMin + vec3(cell) * voxelSize;
    vec3 cellMax = cellMin + vec3(voxelSize);
    vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
    vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
    vec3 tDelta = abs(vec3(voxelSize) / safeDir);

    for (uint i = 0u; i < MAX_LOCAL_STEPS; i++)
    {
        bool inside = localActive &&
                      cell.x >= 0 && cell.x < 4 &&
                      cell.y >= 0 && cell.y < 4 &&
                      cell.z >= 0 && cell.z < 4;
        bool hitNow = inside && IsVoxelSet(occLo, occHi, cell);
        bool writeHit = hitNow && !hit;
        hitCell = SelectIVec3(hitCell, cell, writeHit);
        hit = hit || hitNow;

        bool continueLocal = inside && !hitNow;
        bool stepX = continueLocal && (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
        bool stepY = continueLocal && (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
        bool stepZ = continueLocal && (!stepX) && (!stepY);

        ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
        cell += axisStep * stepDir;

        vec3 stepMask = vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0);
        tMaxAxis += stepMask * tDelta;

        localActive = continueLocal;
    }

    return hit;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizePx = imageSize(outImage);
    bool inBounds = pixel.x < imageSizePx.x && pixel.y < imageSizePx.y;
    ivec2 imageMax = max(imageSizePx - ivec2(1), ivec2(0));
    ivec2 safePixel = clamp(pixel, ivec2(0), imageMax);

    vec3 cameraPos = vec3(LoadF(HDR_CAM_POS_X), LoadF(HDR_CAM_POS_Y), LoadF(HDR_CAM_POS_Z));
    vec3 forward = vec3(LoadF(HDR_CAM_FORWARD_X), LoadF(HDR_CAM_FORWARD_Y), LoadF(HDR_CAM_FORWARD_Z));
    vec3 right = vec3(LoadF(HDR_CAM_RIGHT_X), LoadF(HDR_CAM_RIGHT_Y), LoadF(HDR_CAM_RIGHT_Z));
    vec3 up = vec3(LoadF(HDR_CAM_UP_X), LoadF(HDR_CAM_UP_Y), LoadF(HDR_CAM_UP_Z));
    float tanHalfFov = LoadF(HDR_CAM_TAN_HALF_FOV_Y);
    vec3 gridMin = vec3(LoadF(HDR_GRID_MIN_X), LoadF(HDR_GRID_MIN_Y), LoadF(HDR_GRID_MIN_Z));
    ivec3 gridDim = ivec3(
        int(scene.words[HDR_GRID_DIM_X]),
        int(scene.words[HDR_GRID_DIM_Y]),
        int(scene.words[HDR_GRID_DIM_Z]));
    ivec3 safeGridDim = max(gridDim, ivec3(1));

    uint brickCount = scene.words[HDR_BRICK_COUNT];
    uint brickTableBaseWord = scene.words[HDR_BRICK_TABLE_OFFSET_WORDS];
    uint brickPoolBaseWord = scene.words[HDR_BRICK_POOL_OFFSET_WORDS];

    vec2 uv = (vec2(safePixel) + vec2(0.5)) / max(vec2(imageSizePx), vec2(1.0));
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;

    float aspect = float(imageSizePx.x) / max(float(imageSizePx.y), 1.0);
    vec3 rayDir = normalize(forward + right * (ndc.x * aspect * tanHalfFov) + up * (ndc.y * tanHalfFov));

    vec3 skyHorizon = vec3(0.92, 0.62, 0.34);
    vec3 skyTop = vec3(0.18, 0.35, 0.85);
    float skyT = clamp(rayDir.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 sky = mix(skyHorizon, skyTop, skyT);

    uint firstBrickWord = brickPoolBaseWord;
    float firstVoxelSize = LoadF(firstBrickWord + 5u);
    float brickWorldSize = max(firstVoxelSize * 4.0, 1e-6);
    vec3 gridMax = gridMin + vec3(safeGridDim) * brickWorldSize;

    vec3 safeDir = mix(rayDir, vec3(1e-6), lessThan(abs(rayDir), vec3(1e-6)));
    vec3 invDir = 1.0 / safeDir;
    vec3 t0 = (gridMin - cameraPos) * invDir;
    vec3 t1 = (gridMax - cameraPos) * invDir;
    vec3 tMin3 = min(t0, t1);
    vec3 tMax3 = max(t0, t1);
    float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
    float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

    bool hit = false;
    ivec3 hitCell = ivec3(0);
    uint hitBrickSlot = 0u;

    bool hasValidGrid = all(greaterThan(gridDim, ivec3(0)));
    bool globalActive = hasValidGrid && (brickCount != 0u) && (tExit >= max(tEnter, 0.0));
    float t = max(tEnter, 0.0) + 1e-4;
    vec3 p = cameraPos + rayDir * t;
    vec3 local = clamp((p - gridMin) / brickWorldSize, vec3(0.0), vec3(safeGridDim) - vec3(0.0001));
    ivec3 gridCell = ivec3(floor(local));
    ivec3 stepDir = ivec3(sign(rayDir));
    vec3 cellMin = gridMin + vec3(gridCell) * brickWorldSize;
    vec3 cellMax = cellMin + vec3(brickWorldSize);
    vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
    vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
    vec3 tDelta = abs(vec3(brickWorldSize) / safeDir);

    for (uint i = 0u; i < MAX_GLOBAL_STEPS; i++)
    {
        bool insideGrid = globalActive &&
                          gridCell.x >= 0 && gridCell.x < safeGridDim.x &&
                          gridCell.y >= 0 && gridCell.y < safeGridDim.y &&
                          gridCell.z >= 0 && gridCell.z < safeGridDim.z;
        bool continueGlobal = false;

        if (insideGrid)
        {
            uint gridIndex = GridLinearIndex(gridCell, safeGridDim);
            uint brickSlot = scene.words[brickTableBaseWord + gridIndex];
            bool hasBrick = (brickSlot != EMPTY_BRICK_SLOT) && (brickSlot < brickCount);
            bool localHit = false;
            ivec3 localHitCell = ivec3(0);

            if (hasBrick)
            {
                uint brickBaseWord = brickPoolBaseWord + brickSlot * BRICK_WORD_STRIDE;
                uint occLo = scene.words[brickBaseWord + 0u];
                uint occHi = scene.words[brickBaseWord + 1u];
                vec3 brickMin = vec3(
                    LoadF(brickBaseWord + 2u),
                    LoadF(brickBaseWord + 3u),
                    LoadF(brickBaseWord + 4u));
                float voxelSize = LoadF(brickBaseWord + 5u);
                localHit = TraceBrick(cameraPos, rayDir, safeDir, invDir, occLo, occHi, brickMin, voxelSize, localHitCell);
            }

            bool acceptHit = hasBrick && localHit && !hit;
            hit = hit || (hasBrick && localHit);
            hitCell = SelectIVec3(hitCell, localHitCell, acceptHit);
            hitBrickSlot = SelectUInt(hitBrickSlot, brickSlot, acceptHit);

            continueGlobal = !hit;
            bool stepX = continueGlobal && (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
            bool stepY = continueGlobal && (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
            bool stepZ = continueGlobal && (!stepX) && (!stepY);

            ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
            gridCell += axisStep * stepDir;

            vec3 stepMask = vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0);
            tMaxAxis += stepMask * tDelta;
        }

        globalActive = insideGrid && continueGlobal;
    }

    vec3 cellColor = (vec3(hitCell) + vec3(0.5)) / 4.0;
    vec3 slotColor = vec3(
        float((hitBrickSlot * 73u + 41u) & 255u),
        float((hitBrickSlot * 131u + 29u) & 255u),
        float((hitBrickSlot * 197u + 11u) & 255u)) / 255.0;
    vec3 hitColor = mix(vec3(0.08, 0.10, 0.14), cellColor * 0.6 + slotColor * 0.9, 0.9);
    float hitMask = hit ? 1.0 : 0.0;
    vec3 color = mix(sky, hitColor, hitMask);

    color = GradeColor(color);
    if (inBounds)
    {
        imageStore(outImage, pixel, vec4(color, 1.0));
    }
}
