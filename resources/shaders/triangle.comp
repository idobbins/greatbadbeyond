#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer DataBuffer
{
    uint words[];
} scene;

float EdgeFunction(vec2 a, vec2 b, vec2 p)
{
    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);
}

vec3 GradeColor(vec3 c)
{
    c *= 1.12;

    const vec3 lumaWeights = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(c, lumaWeights);
    c = mix(vec3(luma), c, 1.22);

    c = (c - vec3(0.5)) * 1.14 + vec3(0.5);
    c = clamp(c, vec3(0.0), vec3(8.0));

    c = (c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14);
    return c;
}

float LoadF(uint wordIndex)
{
    return uintBitsToFloat(scene.words[wordIndex]);
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizePx = imageSize(outImage);

    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(imageSizePx);
    vec2 p = vec2(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);

    const uint vertBase = 4u;
    vec2 a = vec2(LoadF(vertBase + 0u), LoadF(vertBase + 1u));
    vec2 b = vec2(LoadF(vertBase + 4u), LoadF(vertBase + 5u));
    vec2 c = vec2(LoadF(vertBase + 8u), LoadF(vertBase + 9u));

    float area = EdgeFunction(a, b, c);
    float w0 = EdgeFunction(b, c, p) / area;
    float w1 = EdgeFunction(c, a, p) / area;
    float w2 = EdgeFunction(a, b, p) / area;

    float inside = step(0.0, w0) * step(0.0, w1) * step(0.0, w2);

    vec3 bg = vec3(0.05, 0.05, 0.08);
    vec3 ca = vec3(1.0, 0.2, 0.2);
    vec3 cb = vec3(0.2, 1.0, 0.2);
    vec3 cc = vec3(0.2, 0.4, 1.0);
    vec3 tri = ca * w0 + cb * w1 + cc * w2;

    vec3 color = mix(bg, tri, inside);
    color = GradeColor(color);
    imageStore(outImage, pixel, vec4(color, 1.0));
}
