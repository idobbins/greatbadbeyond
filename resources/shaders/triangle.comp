#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer DataBuffer
{
    uint words[];
} scene;
layout(push_constant) uniform HeaderPush
{
    uint hdr[32];
} pc;

const uint HDR_CAM_POS_X = 0u;
const uint HDR_CAM_POS_Y = 1u;
const uint HDR_CAM_POS_Z = 2u;
const uint HDR_CAM_YAW = 3u;
const uint HDR_CAM_PITCH = 4u;
const uint HDR_CAM_FOV_Y = 8u;
const uint HDR_GRID_MIN_X = 9u;
const uint HDR_GRID_MIN_Y = 10u;
const uint HDR_GRID_MIN_Z = 11u;
const uint HDR_GRID_DIM_X = 12u;
const uint HDR_GRID_DIM_Y = 13u;
const uint HDR_GRID_DIM_Z = 14u;
const uint HDR_BRICK_COUNT = 15u;
const uint HDR_BRICK_TABLE_OFFSET_WORDS = 16u;
const uint HDR_BRICK_POOL_OFFSET_WORDS = 17u;
const uint HDR_CAM_FORWARD_X = 18u;
const uint HDR_CAM_FORWARD_Y = 19u;
const uint HDR_CAM_FORWARD_Z = 20u;
const uint HDR_CAM_RIGHT_X = 21u;
const uint HDR_CAM_RIGHT_Y = 22u;
const uint HDR_CAM_RIGHT_Z = 23u;
const uint HDR_CAM_UP_X = 24u;
const uint HDR_CAM_UP_Y = 25u;
const uint HDR_CAM_UP_Z = 26u;
const uint HDR_CAM_TAN_HALF_FOV_Y = 27u;
const uint HDR_BRICK_VOXEL_SIZE = 28u;
const uint HDR_MACRO_MASK_OFFSET_WORDS = 29u;
const uint BRICK_WORD_STRIDE = 2u;
const uint MACRO_BRICK_DIM = 4u;
const uint EMPTY_BRICK_SLOT = 0xFFFFFFFFu;
const uint MAX_MACRO_STEPS = 96u;
const uint MAX_MACRO_LOCAL_STEPS = 20u;
const uint MAX_LOCAL_STEPS = 12u;

float LoadHdrF(uint wordIndex)
{
    return uintBitsToFloat(pc.hdr[wordIndex]);
}

const vec3 GROUND_PALETTE[10] = vec3[](
    vec3(0.905882, 1.000000, 0.800000),
    vec3(0.776471, 0.964706, 0.525490),
    vec3(0.709804, 0.894118, 0.458824),
    vec3(0.643137, 0.823529, 0.388235),
    vec3(0.576471, 0.756863, 0.317647),
    vec3(0.509804, 0.690196, 0.231373),
    vec3(0.396078, 0.568627, 0.000000),
    vec3(0.274510, 0.403922, 0.000000),
    vec3(0.160784, 0.243137, 0.000000),
    vec3(0.066667, 0.113725, 0.000000));

uint HashMix32(uint x)
{
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}

uint HashGridCell(ivec3 cell)
{
    uvec3 c = uvec3(cell);
    uint h = c.x * 0x1f123bb5u;
    h ^= c.y * 0x9e3779b9u;
    h ^= c.z * 0x85ebca6bu;
    return HashMix32(h);
}

vec3 GradeColor(vec3 c)
{
    c *= 1.08;

    const vec3 lumaWeights = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(c, lumaWeights);
    c = mix(vec3(luma), c, 1.20);

    c = (c - vec3(0.5)) * 1.10 + vec3(0.5);
    c = clamp(c, vec3(0.0), vec3(8.0));
    c = (c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14);
    return c;
}

bool IsMaskSet4x4x4(uint occLo, uint occHi, ivec3 cell)
{
    // 2-bit Morton packing for x/y/z in [0,3], yielding bit index [0,63].
    uint x = uint(cell.x);
    uint y = uint(cell.y);
    uint z = uint(cell.z);
    uint lowBits = (x & 1u) | ((y & 1u) << 1u) | ((z & 1u) << 2u);
    uint highBits = ((x & 2u) << 2u) | ((y & 2u) << 3u) | ((z & 2u) << 4u);
    uint index = lowBits | highBits;
    uint bit = 1u << (index & 31u);
    uint wordIndex = index >> 5u;
    uvec2 packed = uvec2(occLo, occHi);
    uint word = packed[wordIndex];
    return (word & bit) != 0u;
}

uint GridLinearIndex(ivec3 cell, ivec3 dim)
{
    return uint(cell.x + cell.y * dim.x + cell.z * dim.x * dim.y);
}

bool TraceBrickSegment(
    vec3 rayOrigin,
    vec3 rayDir,
    vec3 safeDir,
    uint occLo,
    uint occHi,
    vec3 brickMin,
    float voxelSize,
    float segmentEnterT,
    float segmentExitT,
    out ivec3 hitCell,
    out ivec3 hitNormal)
{
    if (segmentExitT < segmentEnterT)
    {
        hitCell = ivec3(0);
        hitNormal = ivec3(0, 1, 0);
        return false;
    }

    float tStart = segmentEnterT + 1e-4;
    if (tStart > segmentExitT)
    {
        hitCell = ivec3(0);
        hitNormal = ivec3(0, 1, 0);
        return false;
    }

    vec3 p = rayOrigin + rayDir * tStart;
    float tLimit = max(segmentExitT - tStart, 0.0);
    hitCell = ivec3(0);
    hitNormal = ivec3(0, 1, 0);

    vec3 local = clamp((p - brickMin) / voxelSize, vec3(0.0), vec3(3.9999));
    ivec3 cell = ivec3(floor(local));
    ivec3 stepDir = ivec3(sign(rayDir));
    vec3 absDir = abs(rayDir);
    bool majorX = (absDir.x >= absDir.y) && (absDir.x >= absDir.z);
    bool majorY = (!majorX) && (absDir.y >= absDir.z);
    bool majorZ = (!majorX) && (!majorY);
    ivec3 enterNormal = ivec3(
        majorX ? -stepDir.x : 0,
        majorY ? -stepDir.y : 0,
        majorZ ? -stepDir.z : 0);
    vec3 cellMin = brickMin + vec3(cell) * voxelSize;
    vec3 cellMax = cellMin + vec3(voxelSize);
    vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
    vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
    vec3 tDelta = abs(vec3(voxelSize) / safeDir);

    for (uint i = 0u; i < MAX_LOCAL_STEPS; i++)
    {
        bool inside = cell.x >= 0 && cell.x < 4 &&
                      cell.y >= 0 && cell.y < 4 &&
                      cell.z >= 0 && cell.z < 4;
        if (!inside)
        {
            break;
        }

        if (IsMaskSet4x4x4(occLo, occHi, cell))
        {
            hitCell = cell;
            hitNormal = enterNormal;
            return true;
        }

        bool stepX = (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
        bool stepY = (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
        bool stepZ = (!stepX) && (!stepY);

        ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
        ivec3 nextEnterNormal = -axisStep * stepDir;
        float tNext = stepX ? tMaxAxis.x : (stepY ? tMaxAxis.y : tMaxAxis.z);
        if (tNext > tLimit)
        {
            break;
        }

        cell += axisStep * stepDir;
        tMaxAxis += vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0) * tDelta;
        enterNormal = nextEnterNormal;
    }

    return false;
}

bool TraceMacroSegment(
    vec3 rayOrigin,
    vec3 rayDir,
    vec3 safeDir,
    uint macroOccLo,
    uint macroOccHi,
    ivec3 macroCell,
    ivec3 gridDim,
    vec3 gridMin,
    float brickWorldSize,
    float voxelSize,
    float segmentEnterT,
    float segmentExitT,
    uint brickCount,
    uint brickTableBaseWord,
    uint brickPoolBaseWord,
    out ivec3 hitCell,
    out uint hitBrickSlot,
    out ivec3 hitGridCell,
    out ivec3 hitNormal)
{
    if (segmentExitT < segmentEnterT)
    {
        hitCell = ivec3(0);
        hitBrickSlot = 0u;
        hitGridCell = ivec3(0);
        hitNormal = ivec3(0, 1, 0);
        return false;
    }

    float tStart = segmentEnterT + 1e-4;
    if (tStart > segmentExitT)
    {
        hitCell = ivec3(0);
        hitBrickSlot = 0u;
        hitGridCell = ivec3(0);
        hitNormal = ivec3(0, 1, 0);
        return false;
    }

    vec3 macroMin = gridMin + vec3(macroCell * int(MACRO_BRICK_DIM)) * brickWorldSize;
    vec3 p = rayOrigin + rayDir * tStart;
    float tLimit = max(segmentExitT - tStart, 0.0);
    hitCell = ivec3(0);
    hitBrickSlot = 0u;
    hitGridCell = ivec3(0);
    hitNormal = ivec3(0, 1, 0);

    vec3 local = clamp((p - macroMin) / brickWorldSize, vec3(0.0), vec3(3.9999));
    ivec3 localCell = ivec3(floor(local));
    ivec3 stepDir = ivec3(sign(rayDir));
    vec3 cellMin = macroMin + vec3(localCell) * brickWorldSize;
    vec3 cellMax = cellMin + vec3(brickWorldSize);
    vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
    vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
    vec3 tDelta = abs(vec3(brickWorldSize) / safeDir);
    float localCellEnterT = tStart;

    for (uint i = 0u; i < MAX_MACRO_LOCAL_STEPS; i++)
    {
        bool insideMacro = localCell.x >= 0 && localCell.x < 4 &&
                           localCell.y >= 0 && localCell.y < 4 &&
                           localCell.z >= 0 && localCell.z < 4;
        if (!insideMacro)
        {
            break;
        }

        float localCellExitT = min(segmentExitT, tStart + min(min(tMaxAxis.x, tMaxAxis.y), tMaxAxis.z));
        bool macroBitSet = IsMaskSet4x4x4(macroOccLo, macroOccHi, localCell);
        if (macroBitSet)
        {
            ivec3 gridCell = macroCell * int(MACRO_BRICK_DIM) + localCell;
            bool insideGrid = gridCell.x >= 0 && gridCell.x < gridDim.x &&
                              gridCell.y >= 0 && gridCell.y < gridDim.y &&
                              gridCell.z >= 0 && gridCell.z < gridDim.z;
            if (insideGrid)
            {
                uint gridIndex = GridLinearIndex(gridCell, gridDim);
                uint brickSlot = scene.words[brickTableBaseWord + gridIndex];
                bool hasBrick = (brickSlot != EMPTY_BRICK_SLOT) && (brickSlot < brickCount);
                if (hasBrick)
                {
                    uint brickBaseWord = brickPoolBaseWord + brickSlot * BRICK_WORD_STRIDE;
                    uint occLo = scene.words[brickBaseWord + 0u];
                    uint occHi = scene.words[brickBaseWord + 1u];
                    vec3 brickMin = gridMin + vec3(gridCell) * brickWorldSize;
                    ivec3 localHitCell = ivec3(0);
                    ivec3 localHitNormal = ivec3(0, 1, 0);
                    bool localHit = TraceBrickSegment(
                        rayOrigin,
                        rayDir,
                        safeDir,
                        occLo,
                        occHi,
                        brickMin,
                        voxelSize,
                        localCellEnterT,
                        localCellExitT,
                        localHitCell,
                        localHitNormal);
                    if (localHit)
                    {
                        hitCell = localHitCell;
                        hitBrickSlot = brickSlot;
                        hitGridCell = gridCell;
                        hitNormal = localHitNormal;
                        return true;
                    }
                }
            }
        }

        bool stepX = (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
        bool stepY = (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
        bool stepZ = (!stepX) && (!stepY);

        ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
        float tNext = stepX ? tMaxAxis.x : (stepY ? tMaxAxis.y : tMaxAxis.z);
        if (tNext > tLimit)
        {
            break;
        }

        localCell += axisStep * stepDir;
        tMaxAxis += vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0) * tDelta;
        localCellEnterT = localCellExitT;
    }

    return false;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizePx = imageSize(outImage);
    if (pixel.x >= imageSizePx.x || pixel.y >= imageSizePx.y)
    {
        return;
    }

    vec3 cameraPos = vec3(LoadHdrF(HDR_CAM_POS_X), LoadHdrF(HDR_CAM_POS_Y), LoadHdrF(HDR_CAM_POS_Z));
    vec3 forward = vec3(LoadHdrF(HDR_CAM_FORWARD_X), LoadHdrF(HDR_CAM_FORWARD_Y), LoadHdrF(HDR_CAM_FORWARD_Z));
    vec3 right = vec3(LoadHdrF(HDR_CAM_RIGHT_X), LoadHdrF(HDR_CAM_RIGHT_Y), LoadHdrF(HDR_CAM_RIGHT_Z));
    vec3 up = vec3(LoadHdrF(HDR_CAM_UP_X), LoadHdrF(HDR_CAM_UP_Y), LoadHdrF(HDR_CAM_UP_Z));
    float tanHalfFov = LoadHdrF(HDR_CAM_TAN_HALF_FOV_Y);
    vec3 gridMin = vec3(LoadHdrF(HDR_GRID_MIN_X), LoadHdrF(HDR_GRID_MIN_Y), LoadHdrF(HDR_GRID_MIN_Z));
    ivec3 gridDim = ivec3(
        int(pc.hdr[HDR_GRID_DIM_X]),
        int(pc.hdr[HDR_GRID_DIM_Y]),
        int(pc.hdr[HDR_GRID_DIM_Z]));
    ivec3 safeGridDim = max(gridDim, ivec3(1));

    uint brickCount = pc.hdr[HDR_BRICK_COUNT];
    uint brickTableBaseWord = pc.hdr[HDR_BRICK_TABLE_OFFSET_WORDS];
    uint brickPoolBaseWord = pc.hdr[HDR_BRICK_POOL_OFFSET_WORDS];
    uint macroMaskBaseWord = pc.hdr[HDR_MACRO_MASK_OFFSET_WORDS];

    vec2 uv = (vec2(pixel) + vec2(0.5)) / max(vec2(imageSizePx), vec2(1.0));
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;

    float aspect = float(imageSizePx.x) / max(float(imageSizePx.y), 1.0);
    vec3 rayDir = normalize(forward + right * (ndc.x * aspect * tanHalfFov) + up * (ndc.y * tanHalfFov));

    vec3 skyHorizon = vec3(0.92, 0.62, 0.34);
    vec3 skyTop = vec3(0.18, 0.35, 0.85);
    float skyT = clamp(rayDir.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 sky = mix(skyHorizon, skyTop, skyT);

    float brickWorldSize = max(LoadHdrF(HDR_BRICK_VOXEL_SIZE) * 4.0, 1e-6);
    float voxelSize = brickWorldSize * 0.25;
    float macroWorldSize = brickWorldSize * float(MACRO_BRICK_DIM);
    vec3 gridMax = gridMin + vec3(safeGridDim) * brickWorldSize;

    const float eps = 1e-6;
    vec3 dirSign = sign(rayDir);
    dirSign = mix(vec3(1.0), dirSign, notEqual(dirSign, vec3(0.0)));
    vec3 safeDir = mix(dirSign * vec3(eps), rayDir, greaterThanEqual(abs(rayDir), vec3(eps)));
    vec3 invDir = 1.0 / safeDir;
    vec3 t0 = (gridMin - cameraPos) * invDir;
    vec3 t1 = (gridMax - cameraPos) * invDir;
    vec3 tMin3 = min(t0, t1);
    vec3 tMax3 = max(t0, t1);
    float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
    float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

    bool hit = false;
    ivec3 hitCell = ivec3(0);
    ivec3 hitGridCell = ivec3(0);
    ivec3 hitNormal = ivec3(0, 1, 0);
    uint hitBrickSlot = 0u;
    ivec3 macroDim = max((safeGridDim + ivec3(int(MACRO_BRICK_DIM - 1u))) / int(MACRO_BRICK_DIM), ivec3(1));

    bool hasValidGrid = all(greaterThan(gridDim, ivec3(0)));
    bool canTraceGlobal = hasValidGrid && (brickCount != 0u) && (tExit >= max(tEnter, 0.0));
    if (canTraceGlobal)
    {
        float t = max(tEnter, 0.0) + 1e-4;
        vec3 p = cameraPos + rayDir * t;
        vec3 local = clamp((p - gridMin) / macroWorldSize, vec3(0.0), vec3(macroDim) - vec3(0.0001));
        ivec3 macroCell = ivec3(floor(local));
        ivec3 stepDir = ivec3(sign(rayDir));
        vec3 cellMin = gridMin + vec3(macroCell) * macroWorldSize;
        vec3 cellMax = cellMin + vec3(macroWorldSize);
        vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
        vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
        vec3 tDelta = abs(vec3(macroWorldSize) / safeDir);
        float macroCellEnterT = t;

        for (uint i = 0u; i < MAX_MACRO_STEPS; i++)
        {
            if (macroCellEnterT > tExit)
            {
                break;
            }

            bool insideMacroGrid = macroCell.x >= 0 && macroCell.x < macroDim.x &&
                                   macroCell.y >= 0 && macroCell.y < macroDim.y &&
                                   macroCell.z >= 0 && macroCell.z < macroDim.z;
            if (!insideMacroGrid)
            {
                break;
            }

            float macroCellExitT = min(tExit, t + min(min(tMaxAxis.x, tMaxAxis.y), tMaxAxis.z));
            uint macroIndex = GridLinearIndex(macroCell, macroDim);
            uint macroWordBase = macroMaskBaseWord + macroIndex * BRICK_WORD_STRIDE;
            uint macroOccLo = scene.words[macroWordBase + 0u];
            uint macroOccHi = scene.words[macroWordBase + 1u];
            bool hasMacroData = (macroOccLo | macroOccHi) != 0u;
            ivec3 localHitCell = ivec3(0);
            ivec3 localHitGridCell = ivec3(0);
            ivec3 localHitNormal = ivec3(0, 1, 0);
            uint localHitBrickSlot = 0u;
            bool localHit = false;

            if (hasMacroData)
            {
                localHit = TraceMacroSegment(
                    cameraPos,
                    rayDir,
                    safeDir,
                    macroOccLo,
                    macroOccHi,
                    macroCell,
                    safeGridDim,
                    gridMin,
                    brickWorldSize,
                    voxelSize,
                    macroCellEnterT,
                    macroCellExitT,
                    brickCount,
                    brickTableBaseWord,
                    brickPoolBaseWord,
                    localHitCell,
                    localHitBrickSlot,
                    localHitGridCell,
                    localHitNormal);
            }

            if (localHit && !hit)
            {
                hit = true;
                hitCell = localHitCell;
                hitGridCell = localHitGridCell;
                hitNormal = localHitNormal;
                hitBrickSlot = localHitBrickSlot;
            }
            if (hit)
            {
                break;
            }

            bool stepX = (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
            bool stepY = (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
            bool stepZ = (!stepX) && (!stepY);

            ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
            macroCell += axisStep * stepDir;
            tMaxAxis += vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0) * tDelta;
            macroCellEnterT = macroCellExitT;
        }
    }

    vec3 color = sky;
    if (hit)
    {
        ivec3 hitVoxelCell = hitGridCell * 4 + hitCell;
        uint colorHash = HashGridCell(hitVoxelCell);
        uint paletteIndex = colorHash % 10u;
        vec3 albedo = GROUND_PALETTE[paletteIndex];
        float paletteJitter = float((colorHash >> 8u) & 15u) * (1.0 / 15.0);
        albedo *= mix(0.94, 1.08, paletteJitter);

        vec3 normal = normalize(vec3(hitNormal));
        vec3 lightDir = normalize(vec3(0.36, 0.82, 0.44));
        float ndotl = max(dot(normal, lightDir), 0.0);
        float hemi = clamp(normal.y * 0.5 + 0.5, 0.0, 1.0);
        float lighting = 0.26 + ndotl * 0.58 + hemi * 0.16;
        float altitude = float(hitVoxelCell.y) / max(float(gridDim.y * 4 - 1), 1.0);
        color = albedo * lighting * mix(0.92, 1.05, altitude);
    }

    color = GradeColor(color);
    imageStore(outImage, pixel, vec4(color, 1.0));
}
