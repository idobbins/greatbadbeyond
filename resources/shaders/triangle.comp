#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D outImage;
layout(std430, binding = 1) readonly buffer DataBuffer
{
    uint words[];
} scene;

const uint HDR_CAM_POS_X = 0u;
const uint HDR_CAM_POS_Y = 1u;
const uint HDR_CAM_POS_Z = 2u;
const uint HDR_CAM_YAW = 3u;
const uint HDR_CAM_PITCH = 4u;
const uint HDR_CAM_FOV_Y = 8u;
const uint HDR_GRID_MIN_X = 9u;
const uint HDR_GRID_MIN_Y = 10u;
const uint HDR_GRID_MIN_Z = 11u;
const uint HDR_GRID_DIM_X = 12u;
const uint HDR_GRID_DIM_Y = 13u;
const uint HDR_GRID_DIM_Z = 14u;
const uint HDR_BRICK_COUNT = 15u;
const uint HDR_BRICK_TABLE_OFFSET_WORDS = 16u;
const uint HDR_BRICK_POOL_OFFSET_WORDS = 17u;
const uint BRICK_WORD_STRIDE = 16u;
const uint EMPTY_BRICK_SLOT = 0xFFFFFFFFu;
const uint MAX_GLOBAL_STEPS = 96u;
const uint MAX_LOCAL_STEPS = 64u;

float LoadF(uint wordIndex)
{
    return uintBitsToFloat(scene.words[wordIndex]);
}

vec3 GradeColor(vec3 c)
{
    c *= 1.08;

    const vec3 lumaWeights = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(c, lumaWeights);
    c = mix(vec3(luma), c, 1.20);

    c = (c - vec3(0.5)) * 1.10 + vec3(0.5);
    c = clamp(c, vec3(0.0), vec3(8.0));
    c = (c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14);
    return c;
}

bool IsVoxelSet(uint occLo, uint occHi, ivec3 cell)
{
    uint index = uint(cell.x + cell.y * 4 + cell.z * 16);
    uint bit = 1u << (index & 31u);
    uint word = index < 32u ? occLo : occHi;
    return (word & bit) != 0u;
}

uint GridLinearIndex(ivec3 cell, ivec3 dim)
{
    return uint(cell.x + cell.y * dim.x + cell.z * dim.x * dim.y);
}

bool TraceBrick(vec3 rayOrigin, vec3 rayDir, uint occLo, uint occHi, vec3 brickMin, float voxelSize, out ivec3 hitCell)
{
    vec3 brickMax = brickMin + vec3(voxelSize * 4.0);
    vec3 safeDir = mix(rayDir, vec3(1e-6), lessThan(abs(rayDir), vec3(1e-6)));
    vec3 invDir = 1.0 / safeDir;
    vec3 t0 = (brickMin - rayOrigin) * invDir;
    vec3 t1 = (brickMax - rayOrigin) * invDir;
    vec3 tMin3 = min(t0, t1);
    vec3 tMax3 = max(t0, t1);
    float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
    float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

    bool localActive = tExit >= max(tEnter, 0.0);
    bool hit = false;
    hitCell = ivec3(0);

    float t = max(tEnter, 0.0) + 1e-4;
    vec3 p = rayOrigin + rayDir * t;
    vec3 local = clamp((p - brickMin) / voxelSize, vec3(0.0), vec3(3.9999));
    ivec3 cell = ivec3(floor(local));
    ivec3 stepDir = ivec3(sign(rayDir));
    vec3 cellMin = brickMin + vec3(cell) * voxelSize;
    vec3 cellMax = cellMin + vec3(voxelSize);
    vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
    vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
    vec3 tDelta = abs(vec3(voxelSize) / safeDir);

    for (uint i = 0u; i < MAX_LOCAL_STEPS; i++)
    {
        bool inside = localActive &&
                      cell.x >= 0 && cell.x < 4 &&
                      cell.y >= 0 && cell.y < 4 &&
                      cell.z >= 0 && cell.z < 4;
        bool hitNow = inside && IsVoxelSet(occLo, occHi, cell);
        if (hitNow && !hit)
        {
            hit = true;
            hitCell = cell;
        }

        bool continueLocal = inside && !hitNow;
        bool stepX = continueLocal && (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
        bool stepY = continueLocal && (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
        bool stepZ = continueLocal && (!stepX) && (!stepY);

        ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
        cell += axisStep * stepDir;

        vec3 stepMask = vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0);
        tMaxAxis += stepMask * tDelta;

        localActive = continueLocal;
    }

    return hit;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizePx = imageSize(outImage);
    if (pixel.x >= imageSizePx.x || pixel.y >= imageSizePx.y)
    {
        return;
    }

    vec3 cameraPos = vec3(LoadF(HDR_CAM_POS_X), LoadF(HDR_CAM_POS_Y), LoadF(HDR_CAM_POS_Z));
    float yaw = LoadF(HDR_CAM_YAW);
    float pitch = LoadF(HDR_CAM_PITCH);
    float fovY = LoadF(HDR_CAM_FOV_Y);
    vec3 gridMin = vec3(LoadF(HDR_GRID_MIN_X), LoadF(HDR_GRID_MIN_Y), LoadF(HDR_GRID_MIN_Z));
    ivec3 gridDim = ivec3(
        int(scene.words[HDR_GRID_DIM_X]),
        int(scene.words[HDR_GRID_DIM_Y]),
        int(scene.words[HDR_GRID_DIM_Z]));

    uint brickCount = scene.words[HDR_BRICK_COUNT];
    uint brickTableBaseWord = scene.words[HDR_BRICK_TABLE_OFFSET_WORDS];
    uint brickPoolBaseWord = scene.words[HDR_BRICK_POOL_OFFSET_WORDS];

    float cosPitch = cos(pitch);
    float sinPitch = sin(pitch);
    float cosYaw = cos(yaw);
    float sinYaw = sin(yaw);

    vec3 forward = normalize(vec3(cosPitch * cosYaw, sinPitch, cosPitch * sinYaw));
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(forward, worldUp));
    vec3 up = normalize(cross(right, forward));

    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(imageSizePx);
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;

    float aspect = float(imageSizePx.x) / float(imageSizePx.y);
    float tanHalfFov = tan(fovY * 0.5);
    vec3 rayDir = normalize(forward + right * (ndc.x * aspect * tanHalfFov) + up * (ndc.y * tanHalfFov));

    vec3 skyHorizon = vec3(0.92, 0.62, 0.34);
    vec3 skyTop = vec3(0.18, 0.35, 0.85);
    float skyT = clamp(rayDir.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 sky = mix(skyHorizon, skyTop, skyT);

    bool hit = false;
    ivec3 hitCell = ivec3(0);
    uint hitBrickSlot = 0u;

    bool gridValid = all(greaterThan(gridDim, ivec3(0)));
    if (gridValid && brickCount != 0u)
    {
        float voxelSize = LoadF(brickPoolBaseWord + 5u);
        float brickWorldSize = voxelSize * 4.0;
        vec3 gridMax = gridMin + vec3(gridDim) * brickWorldSize;

        vec3 safeDir = mix(rayDir, vec3(1e-6), lessThan(abs(rayDir), vec3(1e-6)));
        vec3 invDir = 1.0 / safeDir;
        vec3 t0 = (gridMin - cameraPos) * invDir;
        vec3 t1 = (gridMax - cameraPos) * invDir;
        vec3 tMin3 = min(t0, t1);
        vec3 tMax3 = max(t0, t1);
        float tEnter = max(max(tMin3.x, tMin3.y), tMin3.z);
        float tExit = min(min(tMax3.x, tMax3.y), tMax3.z);

        bool globalActive = tExit >= max(tEnter, 0.0);
        float t = max(tEnter, 0.0) + 1e-4;
        vec3 p = cameraPos + rayDir * t;
        vec3 local = clamp((p - gridMin) / brickWorldSize, vec3(0.0), vec3(gridDim) - vec3(0.0001));
        ivec3 gridCell = ivec3(floor(local));
        ivec3 stepDir = ivec3(sign(rayDir));
        vec3 cellMin = gridMin + vec3(gridCell) * brickWorldSize;
        vec3 cellMax = cellMin + vec3(brickWorldSize);
        vec3 nextPlane = mix(cellMin, cellMax, greaterThan(rayDir, vec3(0.0)));
        vec3 tMaxAxis = abs((nextPlane - p) / safeDir);
        vec3 tDelta = abs(vec3(brickWorldSize) / safeDir);

        for (uint i = 0u; i < MAX_GLOBAL_STEPS; i++)
        {
            bool insideGrid = globalActive &&
                              gridCell.x >= 0 && gridCell.x < gridDim.x &&
                              gridCell.y >= 0 && gridCell.y < gridDim.y &&
                              gridCell.z >= 0 && gridCell.z < gridDim.z;

            uint brickSlot = EMPTY_BRICK_SLOT;
            if (insideGrid)
            {
                uint gridIndex = GridLinearIndex(gridCell, gridDim);
                brickSlot = scene.words[brickTableBaseWord + gridIndex];
            }

            bool hasBrick = insideGrid &&
                            brickSlot != EMPTY_BRICK_SLOT &&
                            brickSlot < brickCount &&
                            !hit;
            if (hasBrick)
            {
                uint brickBaseWord = brickPoolBaseWord + brickSlot * BRICK_WORD_STRIDE;
                uint occLo = scene.words[brickBaseWord + 0u];
                uint occHi = scene.words[brickBaseWord + 1u];
                vec3 brickMin = vec3(
                    LoadF(brickBaseWord + 2u),
                    LoadF(brickBaseWord + 3u),
                    LoadF(brickBaseWord + 4u));
                float brickVoxelSize = LoadF(brickBaseWord + 5u);

                ivec3 localHitCell = ivec3(0);
                bool localHit = TraceBrick(cameraPos, rayDir, occLo, occHi, brickMin, brickVoxelSize, localHitCell);
                if (localHit)
                {
                    hit = true;
                    hitCell = localHitCell;
                    hitBrickSlot = brickSlot;
                }
            }

            bool continueGlobal = insideGrid && !hit;
            bool stepX = continueGlobal && (tMaxAxis.x <= tMaxAxis.y) && (tMaxAxis.x <= tMaxAxis.z);
            bool stepY = continueGlobal && (!stepX) && (tMaxAxis.y <= tMaxAxis.z);
            bool stepZ = continueGlobal && (!stepX) && (!stepY);

            ivec3 axisStep = ivec3(stepX ? 1 : 0, stepY ? 1 : 0, stepZ ? 1 : 0);
            gridCell += axisStep * stepDir;

            vec3 stepMask = vec3(stepX ? 1.0 : 0.0, stepY ? 1.0 : 0.0, stepZ ? 1.0 : 0.0);
            tMaxAxis += stepMask * tDelta;

            globalActive = continueGlobal;
        }
    }

    vec3 color = sky;
    if (hit)
    {
        vec3 cellColor = (vec3(hitCell) + vec3(0.5)) / 4.0;
        vec3 slotColor = vec3(
            float((hitBrickSlot * 73u + 41u) & 255u),
            float((hitBrickSlot * 131u + 29u) & 255u),
            float((hitBrickSlot * 197u + 11u) & 255u)) / 255.0;
        color = mix(vec3(0.08, 0.10, 0.14), cellColor * 0.6 + slotColor * 0.9, 0.9);
    }

    color = GradeColor(color);
    imageStore(outImage, pixel, vec4(color, 1.0));
}
