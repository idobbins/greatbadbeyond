#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, set = 0, binding = 0) uniform coherent image2D accumImg;
layout(set = 0, binding = 1) uniform sampler2D blitSampler; // unused, kept for descriptor parity
layout(std430, set = 0, binding = 2) readonly buffer Spheres16 { uvec2 q[]; };
layout(std430, set = 0, binding = 3) readonly buffer MatIds { uint mid[]; };
layout(std430, set = 0, binding = 4) readonly buffer MatAlbedoRoughness { vec4 albRgh[]; };
layout(std430, set = 0, binding = 5) readonly buffer MatEmissive { vec4 emit[]; };
layout(std430, set = 0, binding = 6) readonly buffer GridCells { uvec2 cells[]; };
layout(std430, set = 0, binding = 7) readonly buffer GridIndices { uint cellIndices[]; };

layout(push_constant) uniform PathParams {
    vec2 resolution;
    float time;
    uint frameIndex;

    vec3 camPos;
    float camFov;
    vec3 camForward;
    float camAperture;
    vec3 camRight;
    float camFocus;
    vec3 camUp;
    float camPad;

    vec3 qOrigin;
    float qPad0;
    vec3 qScale;
    float qScaleMax;

    uint sphereCount;
    uint gridCellCount;
    uint gridResolutionX;
    uint gridResolutionY;
    uint gridResolutionZ;
    uint gridIndexCount;
    uint padA;
    uint padB;
} pc;

const vec3 PlaneNormal = vec3(0.0, 1.0, 0.0);
const float PlaneD = 0.0;
const int HIT_NONE = -1;
const int HIT_PLANE = -2;

uint hash32(uint x)
{
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}

float rnd(inout uint s)
{
    s = hash32(s);
    return float(s) * (1.0 / 4294967296.0);
}

struct Ray { vec3 o; vec3 d; };

struct HitInfo
{
    float t;
    vec3 normal;
    int primitive;
};

bool hitSphere(vec3 ro, vec3 rd, vec3 c, float r, float tmin, float tmax, out float t)
{
    vec3 oc = ro - c;
    float b = dot(oc, rd);
    float c0 = dot(oc, oc) - r * r;
    float disc = b * b - c0;
    if (disc <= 0.0)
    {
        return false;
    }

    float s = sqrt(disc);
    float t0 = -b - s;
    float t1 = -b + s;
    float candidate = t0 > tmin ? t0 : t1;
    if ((candidate > tmin) && (candidate < tmax))
    {
        t = candidate;
        return true;
    }
    return false;
}

bool hitPlane(vec3 ro, vec3 rd, vec3 n, float d, float tmin, float tmax, out float t)
{
    float denom = dot(n, rd);
    if (abs(denom) < 1e-4)
    {
        return false;
    }
    float tt = -(dot(n, ro) + d) / denom;
    if ((tt > tmin) && (tt < tmax))
    {
        t = tt;
        return true;
    }
    return false;
}

void decodeSphere(uint idx, out vec3 c, out float r)
{
    uvec2 packed = q[idx];
    vec2 xy = unpackUnorm2x16(packed.x);
    vec2 zr = unpackUnorm2x16(packed.y);
    c = pc.qOrigin + vec3(xy.x, xy.y, zr.x) * pc.qScale;
    r = pc.qScaleMax * (zr.y * zr.y);
}

Ray makePrimary(uvec2 pix, inout uint seed)
{
    vec2 jitter = vec2(rnd(seed), rnd(seed));
    vec2 p = (vec2(pix) + jitter) / max(pc.resolution, vec2(1.0));
    p = 2.0 * p - 1.0;
    float aspect = (pc.resolution.y > 0.0) ? pc.resolution.x / pc.resolution.y : 1.0;
    p.x *= aspect;

    float halfHeight = tan(0.5 * pc.camFov);
    vec3 dir = normalize(pc.camForward + p.x * halfHeight * pc.camRight + p.y * halfHeight * pc.camUp);

    if (pc.camAperture > 0.0)
    {
        float r1 = rnd(seed);
        float r2 = rnd(seed);
        float theta = 6.2831853 * r1;
        float disk = sqrt(r2) * (pc.camAperture * 0.5);
        vec2 lens = disk * vec2(cos(theta), sin(theta));
        vec3 origin = pc.camPos + pc.camRight * lens.x + pc.camUp * lens.y;
        vec3 focusPoint = pc.camPos + dir * pc.camFocus;
        dir = normalize(focusPoint - origin);
        return Ray(origin, dir);
    }

    return Ray(pc.camPos, dir);
}

vec3 sky(vec3 d)
{
    float t = 0.5 * (d.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
}

bool traceSpheresLinear(Ray ray, float tmax, inout HitInfo info)
{
    bool hit = false;
    float best = tmax;

    for (uint i = 0u; i < pc.sphereCount; ++i)
    {
        vec3 c;
        float r;
        decodeSphere(i, c, r);
        float tSphere;
        if (hitSphere(ray.o, ray.d, c, r, 0.001, best, tSphere))
        {
            best = tSphere;
            info.t = tSphere;
            info.normal = normalize((ray.o + ray.d * tSphere) - c);
            info.primitive = int(i);
            hit = true;
        }
    }

    return hit;
}

bool traceUniformGrid(Ray ray, inout HitInfo info)
{
    ivec3 dims = ivec3(int(pc.gridResolutionX), int(pc.gridResolutionY), int(pc.gridResolutionZ));
    if ((pc.gridCellCount == 0u) || (pc.gridIndexCount == 0u) || any(lessThanEqual(dims, ivec3(0))))
    {
        return false;
    }

    vec3 boundsMin = pc.qOrigin;
    vec3 boundsMax = pc.qOrigin + pc.qScale;
    vec3 dir = ray.d;
    vec3 invDir = vec3(
        (abs(dir.x) > 1e-5) ? 1.0 / dir.x : ((dir.x >= 0.0) ? 1e30 : -1e30),
        (abs(dir.y) > 1e-5) ? 1.0 / dir.y : ((dir.y >= 0.0) ? 1e30 : -1e30),
        (abs(dir.z) > 1e-5) ? 1.0 / dir.z : ((dir.z >= 0.0) ? 1e30 : -1e30));

    vec3 t0 = (boundsMin - ray.o) * invDir;
    vec3 t1 = (boundsMax - ray.o) * invDir;
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    float tEnter = max(max(tNear.x, tNear.y), max(tNear.z, 0.0));
    float tExit = min(min(tFar.x, tFar.y), tFar.z);
    if (tExit < tEnter)
    {
        return false;
    }

    vec3 dimF = vec3(dims);
    vec3 cellSize = pc.qScale / dimF;
    vec3 safeSize = max(cellSize, vec3(1e-4));
    float startT = max(tEnter, 0.0);
    vec3 startPos = ray.o + dir * startT;
    vec3 rel = (startPos - boundsMin) / safeSize;
    rel = clamp(rel, vec3(0.0), dimF - vec3(1e-4));
    ivec3 cell = clamp(ivec3(floor(rel)), ivec3(0), dims - ivec3(1));

    ivec3 step = ivec3(
        (dir.x > 0.0) ? 1 : ((dir.x < 0.0) ? -1 : 0),
        (dir.y > 0.0) ? 1 : ((dir.y < 0.0) ? -1 : 0),
        (dir.z > 0.0) ? 1 : ((dir.z < 0.0) ? -1 : 0));

    vec3 cellMin = boundsMin + vec3(cell) * safeSize;
    vec3 cellMax = cellMin + safeSize;

    vec3 tMax;
    tMax.x = (step.x > 0) ? (cellMax.x - ray.o.x) * invDir.x : ((step.x < 0) ? (cellMin.x - ray.o.x) * invDir.x : 1e30);
    tMax.y = (step.y > 0) ? (cellMax.y - ray.o.y) * invDir.y : ((step.y < 0) ? (cellMin.y - ray.o.y) * invDir.y : 1e30);
    tMax.z = (step.z > 0) ? (cellMax.z - ray.o.z) * invDir.z : ((step.z < 0) ? (cellMin.z - ray.o.z) * invDir.z : 1e30);

    vec3 tDelta = vec3(
        (step.x != 0) ? abs(safeSize.x * invDir.x) : 1e30,
        (step.y != 0) ? abs(safeSize.y * invDir.y) : 1e30,
        (step.z != 0) ? abs(safeSize.z * invDir.z) : 1e30);

    float maxDistance = min(tExit, info.t);
    float currentT = startT;
    bool hit = false;
    uint strideY = uint(dims.x);
    uint strideZ = uint(dims.x * dims.y);

    while ((cell.x >= 0) && (cell.x < dims.x) &&
           (cell.y >= 0) && (cell.y < dims.y) &&
           (cell.z >= 0) && (cell.z < dims.z))
    {
        uint cellIndex = uint(cell.x) + strideY * uint(cell.y) + strideZ * uint(cell.z);
        if (cellIndex < pc.gridCellCount)
        {
            uvec2 cellInfo = cells[cellIndex];
            uint offset = cellInfo.x;
            uint count = cellInfo.y;
            if ((count > 0u) && (offset < pc.gridIndexCount))
            {
                uint end = min(offset + count, pc.gridIndexCount);
                for (uint idx = offset; idx < end; ++idx)
                {
                    uint sphereIndex = cellIndices[idx];
                    if (sphereIndex >= pc.sphereCount)
                    {
                        continue;
                    }
                    vec3 c;
                    float r;
                    decodeSphere(sphereIndex, c, r);
                    float tSphere;
                    if (hitSphere(ray.o, ray.d, c, r, 0.001, maxDistance, tSphere))
                    {
                        maxDistance = tSphere;
                        info.t = tSphere;
                        info.normal = normalize((ray.o + ray.d * tSphere) - c);
                        info.primitive = int(sphereIndex);
                        hit = true;
                    }
                }
            }
        }

        if (maxDistance <= currentT)
        {
            break;
        }

        if ((tMax.x < tMax.y) && (tMax.x < tMax.z))
        {
            if (tMax.x > maxDistance)
            {
                break;
            }
            cell.x += step.x;
            currentT = tMax.x;
            tMax.x += tDelta.x;
        }
        else if (tMax.y < tMax.z)
        {
            if (tMax.y > maxDistance)
            {
                break;
            }
            cell.y += step.y;
            currentT = tMax.y;
            tMax.y += tDelta.y;
        }
        else
        {
            if (tMax.z > maxDistance)
            {
                break;
            }
            cell.z += step.z;
            currentT = tMax.z;
            tMax.z += tDelta.z;
        }

        if (currentT > maxDistance || currentT > tExit)
        {
            break;
        }
    }

    return hit;
}

bool traceScene(Ray ray, out HitInfo info)
{
    info.t = 1e30;
    info.normal = vec3(0.0);
    info.primitive = HIT_NONE;
    bool anyHit = false;

    float tPlane;
    if (hitPlane(ray.o, ray.d, PlaneNormal, PlaneD, 0.001, info.t, tPlane))
    {
        info.t = tPlane;
        info.normal = PlaneNormal;
        info.primitive = HIT_PLANE;
        anyHit = true;
    }

    bool gridReady = (pc.gridCellCount > 0u) &&
        (pc.gridIndexCount > 0u) &&
        (pc.gridResolutionX > 0u) &&
        (pc.gridResolutionY > 0u) &&
        (pc.gridResolutionZ > 0u);

    bool sphereHit = false;
    if (gridReady)
    {
        sphereHit = traceUniformGrid(ray, info);
    }
    else
    {
        sphereHit = traceSpheresLinear(ray, info.t, info);
    }

    return anyHit || sphereHit;
}

void main()
{
    uvec2 pix = gl_GlobalInvocationID.xy;
    if ((pix.x >= uint(pc.resolution.x)) || (pix.y >= uint(pc.resolution.y)))
    {
        return;
    }

    uint seed = (pix.x * 1973u) ^ (pix.y * 9277u) ^ (pc.frameIndex * 26699u) ^ 0x68bc21ebu;
    Ray ray = makePrimary(pix, seed);

    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);

    for (int bounce = 0; bounce < 3; ++bounce)
    {
        HitInfo hit;
        bool anyHit = traceScene(ray, hit);
        if (!anyHit)
        {
            radiance += throughput * sky(ray.d);
            break;
        }

        vec3 hitPoint = ray.o + ray.d * hit.t;
        vec3 albedo = vec3(0.8);
        float rough = 1.0;
        vec3 emitCol = vec3(0.0);
        float metallic = 0.0;

        if (hit.primitive == HIT_PLANE)
        {
            albedo = vec3(0.8);
            rough = 1.0;
        }
        else if (hit.primitive >= 0)
        {
            uint midx = mid[hit.primitive];
            vec4 alb = albRgh[midx];
            vec4 emi = emit[midx];
            albedo = alb.xyz;
            rough = alb.w;
            emitCol = emi.xyz;
            metallic = clamp(emi.w, 0.0, 1.0);
        }

        radiance += throughput * emitCol;

        float u1 = rnd(seed);
        float u2 = rnd(seed);
        float r = sqrt(u1);
        float theta = 6.2831853 * u2;
        vec3 tangent = normalize(abs(hit.normal.x) > 0.5 ? cross(hit.normal, vec3(0, 1, 0)) : cross(hit.normal, vec3(1, 0, 0)));
        vec3 bitangent = cross(hit.normal, tangent);
        vec3 hemi = normalize(
            tangent * (r * cos(theta)) +
            bitangent * (r * sin(theta)) +
            hit.normal * sqrt(max(0.0, 1.0 - u1)));

        vec3 diffuseDir = hemi;
        vec3 reflectDir = normalize(reflect(ray.d, hit.normal));
        vec3 specDir = normalize(mix(reflectDir, diffuseDir, clamp(rough, 0.0, 1.0)));
        vec3 newDir = normalize(mix(diffuseDir, specDir, metallic));

        ray.o = hitPoint + hit.normal * 0.001;
        ray.d = newDir;
        vec3 energyColor = mix(albedo, vec3(1.0), metallic);
        throughput *= energyColor;

        if (bounce > 3)
        {
            float p = clamp(max(max(throughput.r, throughput.g), throughput.b), 0.05, 0.98);
            if (rnd(seed) > p)
            {
                break;
            }
            throughput /= p;
        }
    }

    vec4 prev = (pc.frameIndex == 0u)
        ? vec4(0.0)
        : imageLoad(accumImg, ivec2(pix));
    float n = float(pc.frameIndex);
    vec3 avg = (prev.xyz * n + radiance) / (n + 1.0);
    imageStore(accumImg, ivec2(pix), vec4(avg, 1.0));
}
