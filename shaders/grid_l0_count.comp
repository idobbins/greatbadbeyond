#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 2) readonly buffer SphereCenters {
  vec4 centers[];
};

layout(std430, binding = 5) readonly buffer GridParams {
  vec4 bmin;
  vec4 bmax;
  uvec4 dims;
  vec4 inv_cell;
} grid;

layout(std430, binding = 10) buffer L0Counts {
  uint counts[];
};

layout(push_constant) uniform PushConstants {
  vec4 screen_params;
  uvec4 frame_params;
  vec4 physics_params;
} pushc;

uint l0_index(ivec3 c, ivec3 dims) {
  return uint(c.x + dims.x * (c.y + dims.y * c.z));
}

void main() {
  const uint sid = gl_GlobalInvocationID.x;
  const uint sphere_count = pushc.frame_params.z;
  if (sid >= sphere_count) {
    return;
  }

  const vec4 s = centers[sid];
  const vec3 radius = vec3(s.w);
  const vec3 mn = s.xyz - radius;
  const vec3 mx = s.xyz + radius;

  const ivec3 dims = ivec3(grid.dims.xyz);
  if (any(lessThanEqual(dims, ivec3(0)))) {
    return;
  }
  const ivec3 dm1 = max(dims - ivec3(1), ivec3(0));
  const vec3 inv = grid.inv_cell.xyz;

  const ivec3 c0 = clamp(ivec3(floor((mn - grid.bmin.xyz) * inv)), ivec3(0), dm1);
  const ivec3 c1 = clamp(ivec3(floor((mx - grid.bmin.xyz) * inv)), ivec3(0), dm1);

  for (int z = c0.z; z <= c1.z; ++z) {
    for (int y = c0.y; y <= c1.y; ++y) {
      for (int x = c0.x; x <= c1.x; ++x) {
        const uint ci = l0_index(ivec3(x, y, z), dims);
        atomicAdd(counts[ci], 1u);
      }
    }
  }
}
