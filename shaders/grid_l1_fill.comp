#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 2) readonly buffer SphereCenters {
  vec4 centers[];
};

layout(std430, binding = 5) readonly buffer GridParams {
  vec4 bmin;
  vec4 bmax;
  uvec4 dims;
  vec4 inv_cell;
} grid;

layout(std430, binding = 6) readonly buffer GridL0Cells {
  uvec4 l0_cells[];
};

layout(std430, binding = 7) readonly buffer GridL1Cells {
  uvec2 l1_cells[];
};

layout(std430, binding = 8) buffer GridIndices {
  uint cell_indices[];
};

layout(std430, binding = 14) readonly buffer L1Offsets {
  uint offsets[];
};

layout(std430, binding = 15) buffer L1Cursors {
  uint cursors[];
};

layout(std430, binding = 17) readonly buffer Globals {
  uint l0_total;
  uint l1_total;
  uint indices_capacity;
  uint overflow;
} globals;

layout(push_constant) uniform PushConstants {
  vec4 screen_params;
  uvec4 frame_params;
} pushc;

const uint CHILD_DIM = 4u;

uint l0_index(ivec3 c, ivec3 dims) {
  return uint(c.x + dims.x * (c.y + dims.y * c.z));
}

uint l1_index(ivec3 c) {
  return uint(c.x + int(CHILD_DIM) * (c.y + int(CHILD_DIM) * c.z));
}

void main() {
  const uint sid = gl_GlobalInvocationID.x;
  const uint sphere_count = pushc.frame_params.z;
  if (sid >= sphere_count) {
    return;
  }

  const vec4 s = centers[sid];
  const vec3 radius = vec3(s.w);
  const vec3 mn = s.xyz - radius;
  const vec3 mx = s.xyz + radius;

  const ivec3 dims = ivec3(grid.dims.xyz);
  if (any(lessThanEqual(dims, ivec3(0)))) {
    return;
  }
  const ivec3 dm1 = max(dims - ivec3(1), ivec3(0));
  const vec3 inv = grid.inv_cell.xyz;
  const vec3 cell_size = vec3(
    inv.x > 0.0 ? 1.0 / inv.x : 1e30,
    inv.y > 0.0 ? 1.0 / inv.y : 1e30,
    inv.z > 0.0 ? 1.0 / inv.z : 1e30
  );
  const vec3 inv_child = inv * float(CHILD_DIM);
  const ivec3 child_dm1 = ivec3(int(CHILD_DIM) - 1);

  const ivec3 c0 = clamp(ivec3(floor((mn - grid.bmin.xyz) * inv)), ivec3(0), dm1);
  const ivec3 c1 = clamp(ivec3(floor((mx - grid.bmin.xyz) * inv)), ivec3(0), dm1);

  for (int z = c0.z; z <= c1.z; ++z) {
    for (int y = c0.y; y <= c1.y; ++y) {
      for (int x = c0.x; x <= c1.x; ++x) {
        const uint ci = l0_index(ivec3(x, y, z), dims);
        const uvec4 hdr = l0_cells[ci];
        if (hdr.w == 0u) {
          continue;
        }
        const uint child_base = hdr.z;
        const vec3 macro_min = grid.bmin.xyz + vec3(float(x), float(y), float(z)) * cell_size;
        const vec3 local_min = (mn - macro_min) * inv_child;
        const vec3 local_max = (mx - macro_min) * inv_child;
        const ivec3 ch0 = clamp(ivec3(floor(local_min)), ivec3(0), child_dm1);
        const ivec3 ch1 = clamp(ivec3(floor(local_max)), ivec3(0), child_dm1);
        if (any(greaterThan(ch0, ch1))) {
          continue;
        }
        for (int cz = ch0.z; cz <= ch1.z; ++cz) {
          for (int cy = ch0.y; cy <= ch1.y; ++cy) {
            for (int cx = ch0.x; cx <= ch1.x; ++cx) {
              const uint child_idx = child_base + l1_index(ivec3(cx, cy, cz));
              const uint dst = offsets[child_idx] + atomicAdd(cursors[child_idx], 1u);
              if (dst < globals.indices_capacity) {
                cell_indices[dst] = sid;
              }
            }
          }
        }
      }
    }
  }
}
