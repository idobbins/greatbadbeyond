#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform image2D accum_image;

layout(std430, binding = 2) readonly buffer SphereCenters {
  vec4 centers[];
};

layout(std430, binding = 3) readonly buffer SphereAlbedo {
  vec4 albedo[];
};

layout(std140, binding = 4) uniform CameraBuffer {
  vec4 origin;
  vec4 lower_left;
  vec4 horizontal;
  vec4 vertical;
} camera;

layout(std140, binding = 5) uniform GridParams {
  vec4 bmin;
  vec4 bmax;
  uvec4 dims;
  vec4 inv_cell;
} grid;

layout(std430, binding = 6) readonly buffer GridL0Cells {
  uvec4 l0_cells[];
};

layout(std430, binding = 7) readonly buffer GridL1Cells {
  uvec2 l1_cells[];
};

layout(std430, binding = 8) readonly buffer GridIndices {
  uint cell_indices[];
};

layout(push_constant) uniform PushConstants {
  vec4 screen_params;
  uvec4 frame_params;
} pushc;

const float GROUND_Y = -1.0;
const uint MAX_BOUNCES = 4u;
const float T_MIN = 1e-3;
const float T_MAX = 1e30;
const uint MISS_ID = 0xFFFFFFFFu;
const int CHILD_DIM = 4;

uint lcg(inout uint state) {
  state = state * 1664525u + 1013904223u;
  return state;
}

float rand(inout uint state) {
  return float(lcg(state) & 0x00FFFFFFu) / float(0x01000000u);
}

vec3 random_unit_vector(inout uint state) {
  const float z = rand(state) * 2.0 - 1.0;
  const float a = rand(state) * 6.28318530718;
  const float r = sqrt(max(0.0, 1.0 - z * z));
  return vec3(r * cos(a), z, r * sin(a));
}

vec3 random_hemisphere(const vec3 normal, inout uint state) {
  vec3 dir = random_unit_vector(state);
  if (dot(dir, normal) < 0.0) {
    dir = -dir;
  }
  return dir;
}

vec3 evaluate_sky(const vec3 dir) {
  const vec3 unit_dir = normalize(dir);
  const float t = clamp(unit_dir.y * 0.5 + 0.5, 0.0, 1.0);
  return mix(vec3(0.8, 0.9, 1.0), vec3(0.15, 0.2, 0.35), pow(1.0 - t, 2.0));
}

bool intersect_aabb(const vec3 ro, const vec3 rd, const vec3 bmin, const vec3 bmax, out float t0, out float t1) {
  const vec3 inv = vec3(1.0) / rd;
  const vec3 tmin = (bmin - ro) * inv;
  const vec3 tmax = (bmax - ro) * inv;
  const vec3 tsm = min(tmin, tmax);
  const vec3 tbg = max(tmin, tmax);
  t0 = max(max(tsm.x, tsm.y), tsm.z);
  t1 = min(min(tbg.x, tbg.y), tbg.z);
  return t1 >= max(t0, 0.0);
}

bool intersect_sphere(const uint sid, const vec3 ro, const vec3 rd, out float t) {
  const vec4 s = centers[sid];
  const vec3 oc = ro - s.xyz;
  const float b = dot(oc, rd);
  const float c = dot(oc, oc) - s.w * s.w;
  const float disc = b * b - c;
  if (disc < 0.0) {
    return false;
  }
  const float sd = sqrt(disc);
  const float t0 = -b - sd;
  const float t1 = -b + sd;
  if (t0 > T_MIN) {
    t = t0;
    return true;
  }
  if (t1 > T_MIN) {
    t = t1;
    return true;
  }
  return false;
}

uint l0_index(const ivec3 c, const ivec3 dims) {
  return uint(c.x + dims.x * (c.y + dims.y * c.z));
}

uint l1_index(const ivec3 c, const int dim) {
  return uint(c.x + dim * (c.y + dim * c.z));
}

void hit_grid_min(const vec3 ro, const vec3 rd, out float tmin, out uint idmin) {
  tmin = T_MAX;
  idmin = MISS_ID;

  const vec3 g_bmin = grid.bmin.xyz;
  const vec3 g_bmax = grid.bmax.xyz;
  const vec3 g_inv_cell = grid.inv_cell.xyz;
  const ivec3 dims = ivec3(grid.dims.xyz);
  const ivec3 dims_minus_one = max(dims - ivec3(1), ivec3(0));
  const uint l0_count = uint(l0_cells.length());
  const uint l1_count = uint(l1_cells.length());
  const uint index_count = uint(cell_indices.length());
  const uint sphere_count = pushc.frame_params.z;

  if (any(lessThanEqual(dims, ivec3(0)))) {
    return;
  }

  float tg0;
  float tg1;
  if (!intersect_aabb(ro, rd, g_bmin, g_bmax, tg0, tg1)) {
    return;
  }

  const vec3 cell_size = vec3(
    g_inv_cell.x > 0.0 ? 1.0 / g_inv_cell.x : T_MAX,
    g_inv_cell.y > 0.0 ? 1.0 / g_inv_cell.y : T_MAX,
    g_inv_cell.z > 0.0 ? 1.0 / g_inv_cell.z : T_MAX
  );

  float t = max(tg0, 0.0);
  vec3 p = ro + rd * t;
  ivec3 c = clamp(ivec3(floor((p - g_bmin) * g_inv_cell)), ivec3(0), dims_minus_one);

  const ivec3 step = ivec3(rd.x >= 0.0 ? 1 : -1, rd.y >= 0.0 ? 1 : -1, rd.z >= 0.0 ? 1 : -1);
  const vec3 next_boundary = g_bmin + (vec3(c) + vec3(step.x > 0 ? 1.0 : 0.0,
                                                      step.y > 0 ? 1.0 : 0.0,
                                                      step.z > 0 ? 1.0 : 0.0)) * cell_size;

  const vec3 inv_rd = vec3(
    (abs(rd.x) < 1e-8) ? 0.0 : 1.0 / rd.x,
    (abs(rd.y) < 1e-8) ? 0.0 : 1.0 / rd.y,
    (abs(rd.z) < 1e-8) ? 0.0 : 1.0 / rd.z
  );
  vec3 t_max = vec3(
    (abs(rd.x) < 1e-8) ? T_MAX : (next_boundary.x - ro.x) * inv_rd.x,
    (abs(rd.y) < 1e-8) ? T_MAX : (next_boundary.y - ro.y) * inv_rd.y,
    (abs(rd.z) < 1e-8) ? T_MAX : (next_boundary.z - ro.z) * inv_rd.z
  );
  const vec3 t_delta = vec3(
    (abs(rd.x) < 1e-8) ? T_MAX : cell_size.x * abs(inv_rd.x),
    (abs(rd.y) < 1e-8) ? T_MAX : cell_size.y * abs(inv_rd.y),
    (abs(rd.z) < 1e-8) ? T_MAX : cell_size.z * abs(inv_rd.z)
  );

  const vec3 child_cell_size = cell_size / float(CHILD_DIM);

  for (int guard = 0; guard < 8192; ++guard) {
    if (t > tg1) {
      break;
    }

    const float t_cell_exit = min(t_max.x, min(t_max.y, t_max.z));
    const uint ci = l0_index(c, dims);
    if (ci >= l0_count) {
      break;
    }
    const uvec4 h = l0_cells[ci];

    if (h.w == 0u) {
      for (uint k = 0u; k < h.y; ++k) {
        const uint offset = h.x + k;
        if (offset >= index_count) {
          break;
        }
        const uint sid = cell_indices[offset];
        if (sid >= sphere_count) {
          continue;
        }
        float th;
        if (intersect_sphere(sid, ro, rd, th) && th <= t_cell_exit) {
          tmin = th;
          idmin = sid;
          return;
        }
      }
    } else {
      const vec3 macro_min = g_bmin + vec3(c) * cell_size;

      const vec3 pch = ro + rd * t;
      const ivec3 ch_dims = ivec3(CHILD_DIM);
      const ivec3 ch_dims_minus_one = ch_dims - ivec3(1);
      ivec3 cc = clamp(ivec3(floor((pch - macro_min) / child_cell_size)), ivec3(0), ch_dims_minus_one);

      const ivec3 ch_step = step;
      const vec3 ch_next_boundary = macro_min + (vec3(cc) + vec3(ch_step.x > 0 ? 1.0 : 0.0,
                                                                 ch_step.y > 0 ? 1.0 : 0.0,
                                                                 ch_step.z > 0 ? 1.0 : 0.0)) * child_cell_size;
      vec3 ch_t_max = vec3(
        (abs(rd.x) < 1e-8) ? T_MAX : (ch_next_boundary.x - ro.x) * inv_rd.x,
        (abs(rd.y) < 1e-8) ? T_MAX : (ch_next_boundary.y - ro.y) * inv_rd.y,
        (abs(rd.z) < 1e-8) ? T_MAX : (ch_next_boundary.z - ro.z) * inv_rd.z
      );
      const vec3 ch_t_delta = vec3(
        (abs(rd.x) < 1e-8) ? T_MAX : child_cell_size.x * abs(inv_rd.x),
        (abs(rd.y) < 1e-8) ? T_MAX : child_cell_size.y * abs(inv_rd.y),
        (abs(rd.z) < 1e-8) ? T_MAX : child_cell_size.z * abs(inv_rd.z)
      );

      for (int g2 = 0; g2 < 512; ++g2) {
        const float t_ch_exit = min(ch_t_max.x, min(ch_t_max.y, ch_t_max.z));
        if (t > t_cell_exit || t > tg1) {
          break;
        }

        const uint child_index = h.z + l1_index(cc, CHILD_DIM);
        if (child_index >= l1_count) {
          break;
        }
        const uvec2 h1 = l1_cells[child_index];

        for (uint k = 0u; k < h1.y; ++k) {
          const uint offset = h1.x + k;
          if (offset >= index_count) {
            break;
          }
          const uint sid = cell_indices[offset];
          if (sid >= sphere_count) {
            continue;
          }
          float th;
          if (intersect_sphere(sid, ro, rd, th) && th <= min(t_ch_exit, t_cell_exit)) {
            tmin = th;
            idmin = sid;
            return;
          }
        }

        if (ch_t_max.x < ch_t_max.y) {
          if (ch_t_max.x < ch_t_max.z) {
            cc.x += ch_step.x;
            t = ch_t_max.x;
            ch_t_max.x += ch_t_delta.x;
          } else {
            cc.z += ch_step.z;
            t = ch_t_max.z;
            ch_t_max.z += ch_t_delta.z;
          }
        } else {
          if (ch_t_max.y < ch_t_max.z) {
            cc.y += ch_step.y;
            t = ch_t_max.y;
            ch_t_max.y += ch_t_delta.y;
          } else {
            cc.z += ch_step.z;
            t = ch_t_max.z;
            ch_t_max.z += ch_t_delta.z;
          }
        }

        if (any(lessThan(cc, ivec3(0))) || any(greaterThanEqual(cc, ch_dims))) {
          break;
        }
      }
    }

    if (t_max.x < t_max.y) {
      if (t_max.x < t_max.z) {
        c.x += step.x;
        t = t_max.x;
        t_max.x += t_delta.x;
      } else {
        c.z += step.z;
        t = t_max.z;
        t_max.z += t_delta.z;
      }
    } else {
      if (t_max.y < t_max.z) {
        c.y += step.y;
        t = t_max.y;
        t_max.y += t_delta.y;
      } else {
        c.z += step.z;
        t = t_max.z;
        t_max.z += t_delta.z;
      }
    }

    if (any(lessThan(c, ivec3(0))) || any(greaterThanEqual(c, dims))) {
      break;
    }
  }
}

bool intersect_ground(const vec3 ro, const vec3 rd, out float t, out vec3 albedo_out) {
  if (rd.y >= -0.0001) {
    t = 0.0;
    albedo_out = vec3(0.0);
    return false;
  }
  const float hit_t = (GROUND_Y - ro.y) / rd.y;
  if (hit_t <= T_MIN) {
    t = 0.0;
    albedo_out = vec3(0.0);
    return false;
  }
  const vec3 p = ro + rd * hit_t;
  const vec2 checker = floor(p.xz);
  const float pattern = mod(checker.x + checker.y, 2.0);
  albedo_out = mix(vec3(0.8, 0.85, 0.8), vec3(0.3, 0.3, 0.35), pattern);
  t = hit_t;
  return true;
}

void main() {
  const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
  const ivec2 extent = imageSize(accum_image);
  if (pixel.x >= extent.x || pixel.y >= extent.y) {
    return;
  }

  const float inv_width = pushc.screen_params.x;
  const float inv_height = pushc.screen_params.y;
  const uint frame_index = pushc.frame_params.x;
  const uint sample_seed = pushc.frame_params.y;
  const uint sphere_count = pushc.frame_params.z;

  uint rng_state = sample_seed
                 ^ (uint(pixel.x) * 1973u)
                 ^ (uint(pixel.y) * 9277u)
                 ^ (frame_index * 26699u);
  const vec2 jitter = vec2(rand(rng_state), rand(rng_state));
  const vec2 uv = (vec2(pixel) + jitter) * vec2(inv_width, inv_height);
  const float v = 1.0 - uv.y;

  const vec3 ray_origin = camera.origin.xyz;
  const vec3 ray_target = camera.lower_left.xyz
                        + uv.x * camera.horizontal.xyz
                        + v * camera.vertical.xyz;
  const vec3 ray_direction = normalize(ray_target - ray_origin);

  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  vec3 origin = ray_origin;
  vec3 direction = ray_direction;
  bool path_alive = true;

  for (uint bounce = 0u; bounce < MAX_BOUNCES; ++bounce) {
    if (!path_alive) {
      break;
    }

    float t_hit = T_MAX;
    vec3 hit_normal = vec3(0.0);
    vec3 hit_albedo = vec3(0.0);
    bool hit_any = false;

    float t_plane;
    vec3 plane_alb;
    if (intersect_ground(origin, direction, t_plane, plane_alb) && t_plane < t_hit) {
      t_hit = t_plane;
      hit_normal = vec3(0.0, 1.0, 0.0);
      hit_albedo = plane_alb;
      hit_any = true;
    }

    float t_grid;
    uint id_grid;
    hit_grid_min(origin, direction, t_grid, id_grid);
    if (id_grid != MISS_ID && id_grid < sphere_count && t_grid < t_hit) {
      const vec4 sphere = centers[id_grid];
      const vec4 alb = albedo[id_grid];
      const vec3 hit_pos = origin + direction * t_grid;
      hit_normal = normalize(hit_pos - sphere.xyz);
      hit_albedo = alb.xyz;
      t_hit = t_grid;
      hit_any = true;
    }

    if (!hit_any) {
      radiance += throughput * evaluate_sky(direction);
      path_alive = false;
      break;
    }

    throughput *= hit_albedo;
    const vec3 hit_point = origin + direction * t_hit;
    origin = hit_point + hit_normal * 1e-3;
    direction = random_hemisphere(hit_normal, rng_state);

    if (max(max(throughput.x, throughput.y), throughput.z) < 0.001) {
      path_alive = false;
      break;
    }

    if (bounce >= 3u) {
      const float rr_prob = 0.9;
      if (rand(rng_state) > rr_prob) {
        path_alive = false;
        break;
      }
      throughput /= rr_prob;
    }
  }

  if (path_alive) {
    radiance += throughput * evaluate_sky(direction);
  }

  vec3 accumulated = (frame_index == 0u) ? vec3(0.0) : imageLoad(accum_image, pixel).rgb;
  const float frame_f = float(frame_index);
  accumulated = (accumulated * frame_f + radiance) / (frame_f + 1.0);
  imageStore(accum_image, pixel, vec4(accumulated, 1.0));
}
