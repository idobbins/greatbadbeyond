#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 2) readonly buffer SphereCenters {
  vec4 centers[];
};

layout(std430, binding = 5) readonly buffer GridParams {
  vec4 bmin;
  vec4 bmax;
  uvec4 dims;
  vec4 inv_cell;
} grid;

layout(std430, binding = 6) readonly buffer GridL0Cells {
  uvec4 l0_cells[];
};

layout(std430, binding = 8) buffer GridIndices {
  uint cell_indices[];
};

layout(std430, binding = 11) readonly buffer L0Offsets {
  uint offsets[];
};

layout(std430, binding = 12) buffer L0Cursors {
  uint cursors[];
};

layout(std430, binding = 17) readonly buffer Globals {
  uint l0_total;
  uint l1_total;
  uint indices_capacity;
  uint overflow;
} globals;

layout(push_constant) uniform PushConstants {
  vec4 screen_params;
  uvec4 frame_params;
} pushc;

uint l0_index(ivec3 c, ivec3 dims) {
  return uint(c.x + dims.x * (c.y + dims.y * c.z));
}

void main() {
  const uint sid = gl_GlobalInvocationID.x;
  const uint sphere_count = pushc.frame_params.z;
  if (sid >= sphere_count) {
    return;
  }

  const vec4 s = centers[sid];
  const vec3 radius = vec3(s.w);
  const vec3 mn = s.xyz - radius;
  const vec3 mx = s.xyz + radius;

  const ivec3 dims = ivec3(grid.dims.xyz);
  if (any(lessThanEqual(dims, ivec3(0)))) {
    return;
  }
  const ivec3 dm1 = max(dims - ivec3(1), ivec3(0));
  const vec3 inv = grid.inv_cell.xyz;

  const ivec3 c0 = clamp(ivec3(floor((mn - grid.bmin.xyz) * inv)), ivec3(0), dm1);
  const ivec3 c1 = clamp(ivec3(floor((mx - grid.bmin.xyz) * inv)), ivec3(0), dm1);

  for (int z = c0.z; z <= c1.z; ++z) {
    for (int y = c0.y; y <= c1.y; ++y) {
      for (int x = c0.x; x <= c1.x; ++x) {
        const uint ci = l0_index(ivec3(x, y, z), dims);
        const uvec4 hdr = l0_cells[ci];
        if (hdr.w != 0u) {
          continue;
        }
        const uint dst = offsets[ci] + atomicAdd(cursors[ci], 1u);
        if (dst < globals.indices_capacity) {
          cell_indices[dst] = sid;
        }
      }
    }
  }
}
